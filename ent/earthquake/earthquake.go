// Code generated by ent, DO NOT EDIT.

package earthquake

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the earthquake type in the database.
	Label = "earthquake"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldGeoID holds the string denoting the geo_id field in the database.
	FieldGeoID = "geo_id"
	// FieldReportID holds the string denoting the report_id field in the database.
	FieldReportID = "report_id"
	// FieldMag holds the string denoting the mag field in the database.
	FieldMag = "mag"
	// FieldTime holds the string denoting the time field in the database.
	FieldTime = "time"
	// FieldUpdatedTime holds the string denoting the updated_time field in the database.
	FieldUpdatedTime = "updated_time"
	// FieldTz holds the string denoting the tz field in the database.
	FieldTz = "tz"
	// FieldURL holds the string denoting the url field in the database.
	FieldURL = "url"
	// FieldDetail holds the string denoting the detail field in the database.
	FieldDetail = "detail"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldTsunami holds the string denoting the tsunami field in the database.
	FieldTsunami = "tsunami"
	// FieldSig holds the string denoting the sig field in the database.
	FieldSig = "sig"
	// FieldNet holds the string denoting the net field in the database.
	FieldNet = "net"
	// FieldCode holds the string denoting the code field in the database.
	FieldCode = "code"
	// FieldNst holds the string denoting the nst field in the database.
	FieldNst = "nst"
	// FieldDmin holds the string denoting the dmin field in the database.
	FieldDmin = "dmin"
	// FieldRms holds the string denoting the rms field in the database.
	FieldRms = "rms"
	// FieldGap holds the string denoting the gap field in the database.
	FieldGap = "gap"
	// FieldMagType holds the string denoting the mag_type field in the database.
	FieldMagType = "mag_type"
	// FieldEqType holds the string denoting the eq_type field in the database.
	FieldEqType = "eq_type"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// EdgeGeometry holds the string denoting the geometry edge name in mutations.
	EdgeGeometry = "geometry"
	// EdgeReport holds the string denoting the report edge name in mutations.
	EdgeReport = "report"
	// EdgeFtypeEarthquakes holds the string denoting the ftype_earthquakes edge name in mutations.
	EdgeFtypeEarthquakes = "ftype_earthquakes"
	// EdgeSourceEarthquakes holds the string denoting the source_earthquakes edge name in mutations.
	EdgeSourceEarthquakes = "source_earthquakes"
	// Table holds the table name of the earthquake in the database.
	Table = "earthquake"
	// GeometryTable is the table that holds the geometry relation/edge.
	GeometryTable = "earthquake"
	// GeometryInverseTable is the table name for the Geometry entity.
	// It exists in this package in order to avoid circular dependency with the "geometry" package.
	GeometryInverseTable = "geometry"
	// GeometryColumn is the table column denoting the geometry relation/edge.
	GeometryColumn = "geo_id"
	// ReportTable is the table that holds the report relation/edge.
	ReportTable = "earthquake"
	// ReportInverseTable is the table name for the Report entity.
	// It exists in this package in order to avoid circular dependency with the "report" package.
	ReportInverseTable = "report"
	// ReportColumn is the table column denoting the report relation/edge.
	ReportColumn = "report_id"
	// FtypeEarthquakesTable is the table that holds the ftype_earthquakes relation/edge.
	FtypeEarthquakesTable = "ftype_earthquake"
	// FtypeEarthquakesInverseTable is the table name for the FtypeEarthquake entity.
	// It exists in this package in order to avoid circular dependency with the "ftypeearthquake" package.
	FtypeEarthquakesInverseTable = "ftype_earthquake"
	// FtypeEarthquakesColumn is the table column denoting the ftype_earthquakes relation/edge.
	FtypeEarthquakesColumn = "eq_id"
	// SourceEarthquakesTable is the table that holds the source_earthquakes relation/edge.
	SourceEarthquakesTable = "source_earthquake"
	// SourceEarthquakesInverseTable is the table name for the SourceEarthquake entity.
	// It exists in this package in order to avoid circular dependency with the "sourceearthquake" package.
	SourceEarthquakesInverseTable = "source_earthquake"
	// SourceEarthquakesColumn is the table column denoting the source_earthquakes relation/edge.
	SourceEarthquakesColumn = "eq_id"
)

// Columns holds all SQL columns for earthquake fields.
var Columns = []string{
	FieldID,
	FieldGeoID,
	FieldReportID,
	FieldMag,
	FieldTime,
	FieldUpdatedTime,
	FieldTz,
	FieldURL,
	FieldDetail,
	FieldStatus,
	FieldTsunami,
	FieldSig,
	FieldNet,
	FieldCode,
	FieldNst,
	FieldDmin,
	FieldRms,
	FieldGap,
	FieldMagType,
	FieldEqType,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the Earthquake queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByGeoID orders the results by the geo_id field.
func ByGeoID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGeoID, opts...).ToFunc()
}

// ByReportID orders the results by the report_id field.
func ByReportID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReportID, opts...).ToFunc()
}

// ByMag orders the results by the mag field.
func ByMag(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMag, opts...).ToFunc()
}

// ByTime orders the results by the time field.
func ByTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTime, opts...).ToFunc()
}

// ByUpdatedTime orders the results by the updated_time field.
func ByUpdatedTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedTime, opts...).ToFunc()
}

// ByTz orders the results by the tz field.
func ByTz(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTz, opts...).ToFunc()
}

// ByURL orders the results by the url field.
func ByURL(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURL, opts...).ToFunc()
}

// ByDetail orders the results by the detail field.
func ByDetail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDetail, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByTsunami orders the results by the tsunami field.
func ByTsunami(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTsunami, opts...).ToFunc()
}

// BySig orders the results by the sig field.
func BySig(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSig, opts...).ToFunc()
}

// ByNet orders the results by the net field.
func ByNet(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNet, opts...).ToFunc()
}

// ByCode orders the results by the code field.
func ByCode(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCode, opts...).ToFunc()
}

// ByNst orders the results by the nst field.
func ByNst(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNst, opts...).ToFunc()
}

// ByDmin orders the results by the dmin field.
func ByDmin(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDmin, opts...).ToFunc()
}

// ByRms orders the results by the rms field.
func ByRms(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRms, opts...).ToFunc()
}

// ByGap orders the results by the gap field.
func ByGap(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGap, opts...).ToFunc()
}

// ByMagType orders the results by the mag_type field.
func ByMagType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMagType, opts...).ToFunc()
}

// ByEqType orders the results by the eq_type field.
func ByEqType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEqType, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByGeometryField orders the results by geometry field.
func ByGeometryField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newGeometryStep(), sql.OrderByField(field, opts...))
	}
}

// ByReportField orders the results by report field.
func ByReportField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newReportStep(), sql.OrderByField(field, opts...))
	}
}

// ByFtypeEarthquakesCount orders the results by ftype_earthquakes count.
func ByFtypeEarthquakesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFtypeEarthquakesStep(), opts...)
	}
}

// ByFtypeEarthquakes orders the results by ftype_earthquakes terms.
func ByFtypeEarthquakes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFtypeEarthquakesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySourceEarthquakesCount orders the results by source_earthquakes count.
func BySourceEarthquakesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSourceEarthquakesStep(), opts...)
	}
}

// BySourceEarthquakes orders the results by source_earthquakes terms.
func BySourceEarthquakes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSourceEarthquakesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newGeometryStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(GeometryInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, GeometryTable, GeometryColumn),
	)
}
func newReportStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ReportInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ReportTable, ReportColumn),
	)
}
func newFtypeEarthquakesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FtypeEarthquakesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, FtypeEarthquakesTable, FtypeEarthquakesColumn),
	)
}
func newSourceEarthquakesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SourceEarthquakesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SourceEarthquakesTable, SourceEarthquakesColumn),
	)
}
