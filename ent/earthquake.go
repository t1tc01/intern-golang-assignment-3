// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"gitlab.com/hedwig-phan/assignment-3/ent/earthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/geometry"
	"gitlab.com/hedwig-phan/assignment-3/ent/report"
)

// Earthquake is the model entity for the Earthquake schema.
type Earthquake struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// GeoID holds the value of the "geo_id" field.
	GeoID int `json:"geo_id,omitempty"`
	// ReportID holds the value of the "report_id" field.
	ReportID int `json:"report_id,omitempty"`
	// Mag holds the value of the "mag" field.
	Mag float64 `json:"mag,omitempty"`
	// Time holds the value of the "time" field.
	Time time.Time `json:"time,omitempty"`
	// UpdatedTime holds the value of the "updated_time" field.
	UpdatedTime time.Time `json:"updated_time,omitempty"`
	// Tz holds the value of the "tz" field.
	Tz int32 `json:"tz,omitempty"`
	// URL holds the value of the "url" field.
	URL string `json:"url,omitempty"`
	// Detail holds the value of the "detail" field.
	Detail string `json:"detail,omitempty"`
	// Status holds the value of the "status" field.
	Status string `json:"status,omitempty"`
	// Tsunami holds the value of the "tsunami" field.
	Tsunami int32 `json:"tsunami,omitempty"`
	// Sig holds the value of the "sig" field.
	Sig int32 `json:"sig,omitempty"`
	// Net holds the value of the "net" field.
	Net string `json:"net,omitempty"`
	// Code holds the value of the "code" field.
	Code string `json:"code,omitempty"`
	// Nst holds the value of the "nst" field.
	Nst int32 `json:"nst,omitempty"`
	// Dmin holds the value of the "dmin" field.
	Dmin float64 `json:"dmin,omitempty"`
	// Rms holds the value of the "rms" field.
	Rms float64 `json:"rms,omitempty"`
	// Gap holds the value of the "gap" field.
	Gap float64 `json:"gap,omitempty"`
	// MagType holds the value of the "mag_type" field.
	MagType string `json:"mag_type,omitempty"`
	// EqType holds the value of the "eq_type" field.
	EqType string `json:"eq_type,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the EarthquakeQuery when eager-loading is set.
	Edges        EarthquakeEdges `json:"edges"`
	selectValues sql.SelectValues
}

// EarthquakeEdges holds the relations/edges for other nodes in the graph.
type EarthquakeEdges struct {
	// Geometry holds the value of the geometry edge.
	Geometry *Geometry `json:"geometry,omitempty"`
	// Report holds the value of the report edge.
	Report *Report `json:"report,omitempty"`
	// FtypeEarthquakes holds the value of the ftype_earthquakes edge.
	FtypeEarthquakes []*FtypeEarthquake `json:"ftype_earthquakes,omitempty"`
	// SourceEarthquakes holds the value of the source_earthquakes edge.
	SourceEarthquakes []*SourceEarthquake `json:"source_earthquakes,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [4]bool
}

// GeometryOrErr returns the Geometry value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EarthquakeEdges) GeometryOrErr() (*Geometry, error) {
	if e.Geometry != nil {
		return e.Geometry, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: geometry.Label}
	}
	return nil, &NotLoadedError{edge: "geometry"}
}

// ReportOrErr returns the Report value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e EarthquakeEdges) ReportOrErr() (*Report, error) {
	if e.Report != nil {
		return e.Report, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: report.Label}
	}
	return nil, &NotLoadedError{edge: "report"}
}

// FtypeEarthquakesOrErr returns the FtypeEarthquakes value or an error if the edge
// was not loaded in eager-loading.
func (e EarthquakeEdges) FtypeEarthquakesOrErr() ([]*FtypeEarthquake, error) {
	if e.loadedTypes[2] {
		return e.FtypeEarthquakes, nil
	}
	return nil, &NotLoadedError{edge: "ftype_earthquakes"}
}

// SourceEarthquakesOrErr returns the SourceEarthquakes value or an error if the edge
// was not loaded in eager-loading.
func (e EarthquakeEdges) SourceEarthquakesOrErr() ([]*SourceEarthquake, error) {
	if e.loadedTypes[3] {
		return e.SourceEarthquakes, nil
	}
	return nil, &NotLoadedError{edge: "source_earthquakes"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Earthquake) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case earthquake.FieldMag, earthquake.FieldDmin, earthquake.FieldRms, earthquake.FieldGap:
			values[i] = new(sql.NullFloat64)
		case earthquake.FieldID, earthquake.FieldGeoID, earthquake.FieldReportID, earthquake.FieldTz, earthquake.FieldTsunami, earthquake.FieldSig, earthquake.FieldNst:
			values[i] = new(sql.NullInt64)
		case earthquake.FieldURL, earthquake.FieldDetail, earthquake.FieldStatus, earthquake.FieldNet, earthquake.FieldCode, earthquake.FieldMagType, earthquake.FieldEqType:
			values[i] = new(sql.NullString)
		case earthquake.FieldTime, earthquake.FieldUpdatedTime, earthquake.FieldCreatedAt, earthquake.FieldUpdatedAt, earthquake.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Earthquake fields.
func (e *Earthquake) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case earthquake.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			e.ID = int(value.Int64)
		case earthquake.FieldGeoID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field geo_id", values[i])
			} else if value.Valid {
				e.GeoID = int(value.Int64)
			}
		case earthquake.FieldReportID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field report_id", values[i])
			} else if value.Valid {
				e.ReportID = int(value.Int64)
			}
		case earthquake.FieldMag:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field mag", values[i])
			} else if value.Valid {
				e.Mag = value.Float64
			}
		case earthquake.FieldTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field time", values[i])
			} else if value.Valid {
				e.Time = value.Time
			}
		case earthquake.FieldUpdatedTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_time", values[i])
			} else if value.Valid {
				e.UpdatedTime = value.Time
			}
		case earthquake.FieldTz:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tz", values[i])
			} else if value.Valid {
				e.Tz = int32(value.Int64)
			}
		case earthquake.FieldURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field url", values[i])
			} else if value.Valid {
				e.URL = value.String
			}
		case earthquake.FieldDetail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detail", values[i])
			} else if value.Valid {
				e.Detail = value.String
			}
		case earthquake.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				e.Status = value.String
			}
		case earthquake.FieldTsunami:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field tsunami", values[i])
			} else if value.Valid {
				e.Tsunami = int32(value.Int64)
			}
		case earthquake.FieldSig:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sig", values[i])
			} else if value.Valid {
				e.Sig = int32(value.Int64)
			}
		case earthquake.FieldNet:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field net", values[i])
			} else if value.Valid {
				e.Net = value.String
			}
		case earthquake.FieldCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code", values[i])
			} else if value.Valid {
				e.Code = value.String
			}
		case earthquake.FieldNst:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field nst", values[i])
			} else if value.Valid {
				e.Nst = int32(value.Int64)
			}
		case earthquake.FieldDmin:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field dmin", values[i])
			} else if value.Valid {
				e.Dmin = value.Float64
			}
		case earthquake.FieldRms:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field rms", values[i])
			} else if value.Valid {
				e.Rms = value.Float64
			}
		case earthquake.FieldGap:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field gap", values[i])
			} else if value.Valid {
				e.Gap = value.Float64
			}
		case earthquake.FieldMagType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mag_type", values[i])
			} else if value.Valid {
				e.MagType = value.String
			}
		case earthquake.FieldEqType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field eq_type", values[i])
			} else if value.Valid {
				e.EqType = value.String
			}
		case earthquake.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				e.CreatedAt = value.Time
			}
		case earthquake.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				e.UpdatedAt = value.Time
			}
		case earthquake.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				e.DeletedAt = value.Time
			}
		default:
			e.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Earthquake.
// This includes values selected through modifiers, order, etc.
func (e *Earthquake) Value(name string) (ent.Value, error) {
	return e.selectValues.Get(name)
}

// QueryGeometry queries the "geometry" edge of the Earthquake entity.
func (e *Earthquake) QueryGeometry() *GeometryQuery {
	return NewEarthquakeClient(e.config).QueryGeometry(e)
}

// QueryReport queries the "report" edge of the Earthquake entity.
func (e *Earthquake) QueryReport() *ReportQuery {
	return NewEarthquakeClient(e.config).QueryReport(e)
}

// QueryFtypeEarthquakes queries the "ftype_earthquakes" edge of the Earthquake entity.
func (e *Earthquake) QueryFtypeEarthquakes() *FtypeEarthquakeQuery {
	return NewEarthquakeClient(e.config).QueryFtypeEarthquakes(e)
}

// QuerySourceEarthquakes queries the "source_earthquakes" edge of the Earthquake entity.
func (e *Earthquake) QuerySourceEarthquakes() *SourceEarthquakeQuery {
	return NewEarthquakeClient(e.config).QuerySourceEarthquakes(e)
}

// Update returns a builder for updating this Earthquake.
// Note that you need to call Earthquake.Unwrap() before calling this method if this Earthquake
// was returned from a transaction, and the transaction was committed or rolled back.
func (e *Earthquake) Update() *EarthquakeUpdateOne {
	return NewEarthquakeClient(e.config).UpdateOne(e)
}

// Unwrap unwraps the Earthquake entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (e *Earthquake) Unwrap() *Earthquake {
	_tx, ok := e.config.driver.(*txDriver)
	if !ok {
		panic("ent: Earthquake is not a transactional entity")
	}
	e.config.driver = _tx.drv
	return e
}

// String implements the fmt.Stringer.
func (e *Earthquake) String() string {
	var builder strings.Builder
	builder.WriteString("Earthquake(")
	builder.WriteString(fmt.Sprintf("id=%v, ", e.ID))
	builder.WriteString("geo_id=")
	builder.WriteString(fmt.Sprintf("%v", e.GeoID))
	builder.WriteString(", ")
	builder.WriteString("report_id=")
	builder.WriteString(fmt.Sprintf("%v", e.ReportID))
	builder.WriteString(", ")
	builder.WriteString("mag=")
	builder.WriteString(fmt.Sprintf("%v", e.Mag))
	builder.WriteString(", ")
	builder.WriteString("time=")
	builder.WriteString(e.Time.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_time=")
	builder.WriteString(e.UpdatedTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("tz=")
	builder.WriteString(fmt.Sprintf("%v", e.Tz))
	builder.WriteString(", ")
	builder.WriteString("url=")
	builder.WriteString(e.URL)
	builder.WriteString(", ")
	builder.WriteString("detail=")
	builder.WriteString(e.Detail)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(e.Status)
	builder.WriteString(", ")
	builder.WriteString("tsunami=")
	builder.WriteString(fmt.Sprintf("%v", e.Tsunami))
	builder.WriteString(", ")
	builder.WriteString("sig=")
	builder.WriteString(fmt.Sprintf("%v", e.Sig))
	builder.WriteString(", ")
	builder.WriteString("net=")
	builder.WriteString(e.Net)
	builder.WriteString(", ")
	builder.WriteString("code=")
	builder.WriteString(e.Code)
	builder.WriteString(", ")
	builder.WriteString("nst=")
	builder.WriteString(fmt.Sprintf("%v", e.Nst))
	builder.WriteString(", ")
	builder.WriteString("dmin=")
	builder.WriteString(fmt.Sprintf("%v", e.Dmin))
	builder.WriteString(", ")
	builder.WriteString("rms=")
	builder.WriteString(fmt.Sprintf("%v", e.Rms))
	builder.WriteString(", ")
	builder.WriteString("gap=")
	builder.WriteString(fmt.Sprintf("%v", e.Gap))
	builder.WriteString(", ")
	builder.WriteString("mag_type=")
	builder.WriteString(e.MagType)
	builder.WriteString(", ")
	builder.WriteString("eq_type=")
	builder.WriteString(e.EqType)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(e.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(e.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(e.DeletedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Earthquakes is a parsable slice of Earthquake.
type Earthquakes []*Earthquake
