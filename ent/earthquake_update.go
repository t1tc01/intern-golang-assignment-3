// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"gitlab.com/hedwig-phan/assignment-3/ent/earthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/ftypeearthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/geometry"
	"gitlab.com/hedwig-phan/assignment-3/ent/predicate"
	"gitlab.com/hedwig-phan/assignment-3/ent/report"
	"gitlab.com/hedwig-phan/assignment-3/ent/sourceearthquake"
)

// EarthquakeUpdate is the builder for updating Earthquake entities.
type EarthquakeUpdate struct {
	config
	hooks    []Hook
	mutation *EarthquakeMutation
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (eu *EarthquakeUpdate) Where(ps ...predicate.Earthquake) *EarthquakeUpdate {
	eu.mutation.Where(ps...)
	return eu
}

// SetGeoID sets the "geo_id" field.
func (eu *EarthquakeUpdate) SetGeoID(i int) *EarthquakeUpdate {
	eu.mutation.SetGeoID(i)
	return eu
}

// SetNillableGeoID sets the "geo_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableGeoID(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetGeoID(*i)
	}
	return eu
}

// ClearGeoID clears the value of the "geo_id" field.
func (eu *EarthquakeUpdate) ClearGeoID() *EarthquakeUpdate {
	eu.mutation.ClearGeoID()
	return eu
}

// SetReportID sets the "report_id" field.
func (eu *EarthquakeUpdate) SetReportID(i int) *EarthquakeUpdate {
	eu.mutation.SetReportID(i)
	return eu
}

// SetNillableReportID sets the "report_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableReportID(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetReportID(*i)
	}
	return eu
}

// ClearReportID clears the value of the "report_id" field.
func (eu *EarthquakeUpdate) ClearReportID() *EarthquakeUpdate {
	eu.mutation.ClearReportID()
	return eu
}

// SetMag sets the "mag" field.
func (eu *EarthquakeUpdate) SetMag(f float64) *EarthquakeUpdate {
	eu.mutation.ResetMag()
	eu.mutation.SetMag(f)
	return eu
}

// SetNillableMag sets the "mag" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMag(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetMag(*f)
	}
	return eu
}

// AddMag adds f to the "mag" field.
func (eu *EarthquakeUpdate) AddMag(f float64) *EarthquakeUpdate {
	eu.mutation.AddMag(f)
	return eu
}

// SetTime sets the "time" field.
func (eu *EarthquakeUpdate) SetTime(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetTime(t)
	return eu
}

// SetNillableTime sets the "time" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTime(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetTime(*t)
	}
	return eu
}

// SetUpdatedTime sets the "updated_time" field.
func (eu *EarthquakeUpdate) SetUpdatedTime(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetUpdatedTime(t)
	return eu
}

// SetNillableUpdatedTime sets the "updated_time" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableUpdatedTime(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetUpdatedTime(*t)
	}
	return eu
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (eu *EarthquakeUpdate) ClearUpdatedTime() *EarthquakeUpdate {
	eu.mutation.ClearUpdatedTime()
	return eu
}

// SetTz sets the "tz" field.
func (eu *EarthquakeUpdate) SetTz(i int32) *EarthquakeUpdate {
	eu.mutation.ResetTz()
	eu.mutation.SetTz(i)
	return eu
}

// SetNillableTz sets the "tz" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTz(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetTz(*i)
	}
	return eu
}

// AddTz adds i to the "tz" field.
func (eu *EarthquakeUpdate) AddTz(i int32) *EarthquakeUpdate {
	eu.mutation.AddTz(i)
	return eu
}

// ClearTz clears the value of the "tz" field.
func (eu *EarthquakeUpdate) ClearTz() *EarthquakeUpdate {
	eu.mutation.ClearTz()
	return eu
}

// SetURL sets the "url" field.
func (eu *EarthquakeUpdate) SetURL(s string) *EarthquakeUpdate {
	eu.mutation.SetURL(s)
	return eu
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableURL(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetURL(*s)
	}
	return eu
}

// ClearURL clears the value of the "url" field.
func (eu *EarthquakeUpdate) ClearURL() *EarthquakeUpdate {
	eu.mutation.ClearURL()
	return eu
}

// SetDetail sets the "detail" field.
func (eu *EarthquakeUpdate) SetDetail(s string) *EarthquakeUpdate {
	eu.mutation.SetDetail(s)
	return eu
}

// SetNillableDetail sets the "detail" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDetail(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetDetail(*s)
	}
	return eu
}

// ClearDetail clears the value of the "detail" field.
func (eu *EarthquakeUpdate) ClearDetail() *EarthquakeUpdate {
	eu.mutation.ClearDetail()
	return eu
}

// SetStatus sets the "status" field.
func (eu *EarthquakeUpdate) SetStatus(s string) *EarthquakeUpdate {
	eu.mutation.SetStatus(s)
	return eu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableStatus(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetStatus(*s)
	}
	return eu
}

// ClearStatus clears the value of the "status" field.
func (eu *EarthquakeUpdate) ClearStatus() *EarthquakeUpdate {
	eu.mutation.ClearStatus()
	return eu
}

// SetTsunami sets the "tsunami" field.
func (eu *EarthquakeUpdate) SetTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.ResetTsunami()
	eu.mutation.SetTsunami(i)
	return eu
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTsunami(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetTsunami(*i)
	}
	return eu
}

// AddTsunami adds i to the "tsunami" field.
func (eu *EarthquakeUpdate) AddTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.AddTsunami(i)
	return eu
}

// ClearTsunami clears the value of the "tsunami" field.
func (eu *EarthquakeUpdate) ClearTsunami() *EarthquakeUpdate {
	eu.mutation.ClearTsunami()
	return eu
}

// SetSig sets the "sig" field.
func (eu *EarthquakeUpdate) SetSig(i int32) *EarthquakeUpdate {
	eu.mutation.ResetSig()
	eu.mutation.SetSig(i)
	return eu
}

// SetNillableSig sets the "sig" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableSig(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetSig(*i)
	}
	return eu
}

// AddSig adds i to the "sig" field.
func (eu *EarthquakeUpdate) AddSig(i int32) *EarthquakeUpdate {
	eu.mutation.AddSig(i)
	return eu
}

// ClearSig clears the value of the "sig" field.
func (eu *EarthquakeUpdate) ClearSig() *EarthquakeUpdate {
	eu.mutation.ClearSig()
	return eu
}

// SetNet sets the "net" field.
func (eu *EarthquakeUpdate) SetNet(s string) *EarthquakeUpdate {
	eu.mutation.SetNet(s)
	return eu
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNet(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetNet(*s)
	}
	return eu
}

// ClearNet clears the value of the "net" field.
func (eu *EarthquakeUpdate) ClearNet() *EarthquakeUpdate {
	eu.mutation.ClearNet()
	return eu
}

// SetCode sets the "code" field.
func (eu *EarthquakeUpdate) SetCode(s string) *EarthquakeUpdate {
	eu.mutation.SetCode(s)
	return eu
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableCode(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetCode(*s)
	}
	return eu
}

// ClearCode clears the value of the "code" field.
func (eu *EarthquakeUpdate) ClearCode() *EarthquakeUpdate {
	eu.mutation.ClearCode()
	return eu
}

// SetNst sets the "nst" field.
func (eu *EarthquakeUpdate) SetNst(i int32) *EarthquakeUpdate {
	eu.mutation.ResetNst()
	eu.mutation.SetNst(i)
	return eu
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNst(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetNst(*i)
	}
	return eu
}

// AddNst adds i to the "nst" field.
func (eu *EarthquakeUpdate) AddNst(i int32) *EarthquakeUpdate {
	eu.mutation.AddNst(i)
	return eu
}

// ClearNst clears the value of the "nst" field.
func (eu *EarthquakeUpdate) ClearNst() *EarthquakeUpdate {
	eu.mutation.ClearNst()
	return eu
}

// SetDmin sets the "dmin" field.
func (eu *EarthquakeUpdate) SetDmin(f float64) *EarthquakeUpdate {
	eu.mutation.ResetDmin()
	eu.mutation.SetDmin(f)
	return eu
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDmin(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetDmin(*f)
	}
	return eu
}

// AddDmin adds f to the "dmin" field.
func (eu *EarthquakeUpdate) AddDmin(f float64) *EarthquakeUpdate {
	eu.mutation.AddDmin(f)
	return eu
}

// ClearDmin clears the value of the "dmin" field.
func (eu *EarthquakeUpdate) ClearDmin() *EarthquakeUpdate {
	eu.mutation.ClearDmin()
	return eu
}

// SetRms sets the "rms" field.
func (eu *EarthquakeUpdate) SetRms(f float64) *EarthquakeUpdate {
	eu.mutation.ResetRms()
	eu.mutation.SetRms(f)
	return eu
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableRms(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetRms(*f)
	}
	return eu
}

// AddRms adds f to the "rms" field.
func (eu *EarthquakeUpdate) AddRms(f float64) *EarthquakeUpdate {
	eu.mutation.AddRms(f)
	return eu
}

// ClearRms clears the value of the "rms" field.
func (eu *EarthquakeUpdate) ClearRms() *EarthquakeUpdate {
	eu.mutation.ClearRms()
	return eu
}

// SetGap sets the "gap" field.
func (eu *EarthquakeUpdate) SetGap(f float64) *EarthquakeUpdate {
	eu.mutation.ResetGap()
	eu.mutation.SetGap(f)
	return eu
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableGap(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetGap(*f)
	}
	return eu
}

// AddGap adds f to the "gap" field.
func (eu *EarthquakeUpdate) AddGap(f float64) *EarthquakeUpdate {
	eu.mutation.AddGap(f)
	return eu
}

// ClearGap clears the value of the "gap" field.
func (eu *EarthquakeUpdate) ClearGap() *EarthquakeUpdate {
	eu.mutation.ClearGap()
	return eu
}

// SetMagType sets the "mag_type" field.
func (eu *EarthquakeUpdate) SetMagType(s string) *EarthquakeUpdate {
	eu.mutation.SetMagType(s)
	return eu
}

// SetNillableMagType sets the "mag_type" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMagType(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetMagType(*s)
	}
	return eu
}

// ClearMagType clears the value of the "mag_type" field.
func (eu *EarthquakeUpdate) ClearMagType() *EarthquakeUpdate {
	eu.mutation.ClearMagType()
	return eu
}

// SetEqType sets the "eq_type" field.
func (eu *EarthquakeUpdate) SetEqType(s string) *EarthquakeUpdate {
	eu.mutation.SetEqType(s)
	return eu
}

// SetNillableEqType sets the "eq_type" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableEqType(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetEqType(*s)
	}
	return eu
}

// ClearEqType clears the value of the "eq_type" field.
func (eu *EarthquakeUpdate) ClearEqType() *EarthquakeUpdate {
	eu.mutation.ClearEqType()
	return eu
}

// SetCreatedAt sets the "created_at" field.
func (eu *EarthquakeUpdate) SetCreatedAt(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetCreatedAt(t)
	return eu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableCreatedAt(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetCreatedAt(*t)
	}
	return eu
}

// SetUpdatedAt sets the "updated_at" field.
func (eu *EarthquakeUpdate) SetUpdatedAt(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetUpdatedAt(t)
	return eu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableUpdatedAt(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetUpdatedAt(*t)
	}
	return eu
}

// SetDeletedAt sets the "deleted_at" field.
func (eu *EarthquakeUpdate) SetDeletedAt(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetDeletedAt(t)
	return eu
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDeletedAt(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetDeletedAt(*t)
	}
	return eu
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (eu *EarthquakeUpdate) ClearDeletedAt() *EarthquakeUpdate {
	eu.mutation.ClearDeletedAt()
	return eu
}

// SetGeometryID sets the "geometry" edge to the Geometry entity by ID.
func (eu *EarthquakeUpdate) SetGeometryID(id int) *EarthquakeUpdate {
	eu.mutation.SetGeometryID(id)
	return eu
}

// SetNillableGeometryID sets the "geometry" edge to the Geometry entity by ID if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableGeometryID(id *int) *EarthquakeUpdate {
	if id != nil {
		eu = eu.SetGeometryID(*id)
	}
	return eu
}

// SetGeometry sets the "geometry" edge to the Geometry entity.
func (eu *EarthquakeUpdate) SetGeometry(g *Geometry) *EarthquakeUpdate {
	return eu.SetGeometryID(g.ID)
}

// SetReport sets the "report" edge to the Report entity.
func (eu *EarthquakeUpdate) SetReport(r *Report) *EarthquakeUpdate {
	return eu.SetReportID(r.ID)
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (eu *EarthquakeUpdate) AddFtypeEarthquakeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.AddFtypeEarthquakeIDs(ids...)
	return eu
}

// AddFtypeEarthquakes adds the "ftype_earthquakes" edges to the FtypeEarthquake entity.
func (eu *EarthquakeUpdate) AddFtypeEarthquakes(f ...*FtypeEarthquake) *EarthquakeUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.AddFtypeEarthquakeIDs(ids...)
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (eu *EarthquakeUpdate) AddSourceEarthquakeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.AddSourceEarthquakeIDs(ids...)
	return eu
}

// AddSourceEarthquakes adds the "source_earthquakes" edges to the SourceEarthquake entity.
func (eu *EarthquakeUpdate) AddSourceEarthquakes(s ...*SourceEarthquake) *EarthquakeUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return eu.AddSourceEarthquakeIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (eu *EarthquakeUpdate) Mutation() *EarthquakeMutation {
	return eu.mutation
}

// ClearGeometry clears the "geometry" edge to the Geometry entity.
func (eu *EarthquakeUpdate) ClearGeometry() *EarthquakeUpdate {
	eu.mutation.ClearGeometry()
	return eu
}

// ClearReport clears the "report" edge to the Report entity.
func (eu *EarthquakeUpdate) ClearReport() *EarthquakeUpdate {
	eu.mutation.ClearReport()
	return eu
}

// ClearFtypeEarthquakes clears all "ftype_earthquakes" edges to the FtypeEarthquake entity.
func (eu *EarthquakeUpdate) ClearFtypeEarthquakes() *EarthquakeUpdate {
	eu.mutation.ClearFtypeEarthquakes()
	return eu
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to FtypeEarthquake entities by IDs.
func (eu *EarthquakeUpdate) RemoveFtypeEarthquakeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.RemoveFtypeEarthquakeIDs(ids...)
	return eu
}

// RemoveFtypeEarthquakes removes "ftype_earthquakes" edges to FtypeEarthquake entities.
func (eu *EarthquakeUpdate) RemoveFtypeEarthquakes(f ...*FtypeEarthquake) *EarthquakeUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return eu.RemoveFtypeEarthquakeIDs(ids...)
}

// ClearSourceEarthquakes clears all "source_earthquakes" edges to the SourceEarthquake entity.
func (eu *EarthquakeUpdate) ClearSourceEarthquakes() *EarthquakeUpdate {
	eu.mutation.ClearSourceEarthquakes()
	return eu
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to SourceEarthquake entities by IDs.
func (eu *EarthquakeUpdate) RemoveSourceEarthquakeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.RemoveSourceEarthquakeIDs(ids...)
	return eu
}

// RemoveSourceEarthquakes removes "source_earthquakes" edges to SourceEarthquake entities.
func (eu *EarthquakeUpdate) RemoveSourceEarthquakes(s ...*SourceEarthquake) *EarthquakeUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return eu.RemoveSourceEarthquakeIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (eu *EarthquakeUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, eu.sqlSave, eu.mutation, eu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eu *EarthquakeUpdate) SaveX(ctx context.Context) int {
	affected, err := eu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eu *EarthquakeUpdate) Exec(ctx context.Context) error {
	_, err := eu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eu *EarthquakeUpdate) ExecX(ctx context.Context) {
	if err := eu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (eu *EarthquakeUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt))
	if ps := eu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eu.mutation.Mag(); ok {
		_spec.SetField(earthquake.FieldMag, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedMag(); ok {
		_spec.AddField(earthquake.FieldMag, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.Time(); ok {
		_spec.SetField(earthquake.FieldTime, field.TypeTime, value)
	}
	if value, ok := eu.mutation.UpdatedTime(); ok {
		_spec.SetField(earthquake.FieldUpdatedTime, field.TypeTime, value)
	}
	if eu.mutation.UpdatedTimeCleared() {
		_spec.ClearField(earthquake.FieldUpdatedTime, field.TypeTime)
	}
	if value, ok := eu.mutation.Tz(); ok {
		_spec.SetField(earthquake.FieldTz, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedTz(); ok {
		_spec.AddField(earthquake.FieldTz, field.TypeInt32, value)
	}
	if eu.mutation.TzCleared() {
		_spec.ClearField(earthquake.FieldTz, field.TypeInt32)
	}
	if value, ok := eu.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if eu.mutation.URLCleared() {
		_spec.ClearField(earthquake.FieldURL, field.TypeString)
	}
	if value, ok := eu.mutation.Detail(); ok {
		_spec.SetField(earthquake.FieldDetail, field.TypeString, value)
	}
	if eu.mutation.DetailCleared() {
		_spec.ClearField(earthquake.FieldDetail, field.TypeString)
	}
	if value, ok := eu.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if eu.mutation.StatusCleared() {
		_spec.ClearField(earthquake.FieldStatus, field.TypeString)
	}
	if value, ok := eu.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if eu.mutation.TsunamiCleared() {
		_spec.ClearField(earthquake.FieldTsunami, field.TypeInt32)
	}
	if value, ok := eu.mutation.Sig(); ok {
		_spec.SetField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedSig(); ok {
		_spec.AddField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if eu.mutation.SigCleared() {
		_spec.ClearField(earthquake.FieldSig, field.TypeInt32)
	}
	if value, ok := eu.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if eu.mutation.NetCleared() {
		_spec.ClearField(earthquake.FieldNet, field.TypeString)
	}
	if value, ok := eu.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if eu.mutation.CodeCleared() {
		_spec.ClearField(earthquake.FieldCode, field.TypeString)
	}
	if value, ok := eu.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if eu.mutation.NstCleared() {
		_spec.ClearField(earthquake.FieldNst, field.TypeInt32)
	}
	if value, ok := eu.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if eu.mutation.DminCleared() {
		_spec.ClearField(earthquake.FieldDmin, field.TypeFloat64)
	}
	if value, ok := eu.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if eu.mutation.RmsCleared() {
		_spec.ClearField(earthquake.FieldRms, field.TypeFloat64)
	}
	if value, ok := eu.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if eu.mutation.GapCleared() {
		_spec.ClearField(earthquake.FieldGap, field.TypeFloat64)
	}
	if value, ok := eu.mutation.MagType(); ok {
		_spec.SetField(earthquake.FieldMagType, field.TypeString, value)
	}
	if eu.mutation.MagTypeCleared() {
		_spec.ClearField(earthquake.FieldMagType, field.TypeString)
	}
	if value, ok := eu.mutation.EqType(); ok {
		_spec.SetField(earthquake.FieldEqType, field.TypeString, value)
	}
	if eu.mutation.EqTypeCleared() {
		_spec.ClearField(earthquake.FieldEqType, field.TypeString)
	}
	if value, ok := eu.mutation.CreatedAt(); ok {
		_spec.SetField(earthquake.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := eu.mutation.UpdatedAt(); ok {
		_spec.SetField(earthquake.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := eu.mutation.DeletedAt(); ok {
		_spec.SetField(earthquake.FieldDeletedAt, field.TypeTime, value)
	}
	if eu.mutation.DeletedAtCleared() {
		_spec.ClearField(earthquake.FieldDeletedAt, field.TypeTime)
	}
	if eu.mutation.GeometryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.GeometryTable,
			Columns: []string{earthquake.GeometryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.GeometryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.GeometryTable,
			Columns: []string{earthquake.GeometryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.ReportCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.ReportTable,
			Columns: []string{earthquake.ReportColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(report.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.ReportIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.ReportTable,
			Columns: []string{earthquake.ReportColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(report.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.FtypeEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedFtypeEarthquakesIDs(); len(nodes) > 0 && !eu.mutation.FtypeEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.FtypeEarthquakesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.SourceEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedSourceEarthquakesIDs(); len(nodes) > 0 && !eu.mutation.SourceEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.SourceEarthquakesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, eu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	eu.mutation.done = true
	return n, nil
}

// EarthquakeUpdateOne is the builder for updating a single Earthquake entity.
type EarthquakeUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *EarthquakeMutation
}

// SetGeoID sets the "geo_id" field.
func (euo *EarthquakeUpdateOne) SetGeoID(i int) *EarthquakeUpdateOne {
	euo.mutation.SetGeoID(i)
	return euo
}

// SetNillableGeoID sets the "geo_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableGeoID(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetGeoID(*i)
	}
	return euo
}

// ClearGeoID clears the value of the "geo_id" field.
func (euo *EarthquakeUpdateOne) ClearGeoID() *EarthquakeUpdateOne {
	euo.mutation.ClearGeoID()
	return euo
}

// SetReportID sets the "report_id" field.
func (euo *EarthquakeUpdateOne) SetReportID(i int) *EarthquakeUpdateOne {
	euo.mutation.SetReportID(i)
	return euo
}

// SetNillableReportID sets the "report_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableReportID(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetReportID(*i)
	}
	return euo
}

// ClearReportID clears the value of the "report_id" field.
func (euo *EarthquakeUpdateOne) ClearReportID() *EarthquakeUpdateOne {
	euo.mutation.ClearReportID()
	return euo
}

// SetMag sets the "mag" field.
func (euo *EarthquakeUpdateOne) SetMag(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetMag()
	euo.mutation.SetMag(f)
	return euo
}

// SetNillableMag sets the "mag" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMag(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetMag(*f)
	}
	return euo
}

// AddMag adds f to the "mag" field.
func (euo *EarthquakeUpdateOne) AddMag(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddMag(f)
	return euo
}

// SetTime sets the "time" field.
func (euo *EarthquakeUpdateOne) SetTime(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetTime(t)
	return euo
}

// SetNillableTime sets the "time" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTime(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetTime(*t)
	}
	return euo
}

// SetUpdatedTime sets the "updated_time" field.
func (euo *EarthquakeUpdateOne) SetUpdatedTime(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetUpdatedTime(t)
	return euo
}

// SetNillableUpdatedTime sets the "updated_time" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableUpdatedTime(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetUpdatedTime(*t)
	}
	return euo
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (euo *EarthquakeUpdateOne) ClearUpdatedTime() *EarthquakeUpdateOne {
	euo.mutation.ClearUpdatedTime()
	return euo
}

// SetTz sets the "tz" field.
func (euo *EarthquakeUpdateOne) SetTz(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetTz()
	euo.mutation.SetTz(i)
	return euo
}

// SetNillableTz sets the "tz" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTz(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetTz(*i)
	}
	return euo
}

// AddTz adds i to the "tz" field.
func (euo *EarthquakeUpdateOne) AddTz(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddTz(i)
	return euo
}

// ClearTz clears the value of the "tz" field.
func (euo *EarthquakeUpdateOne) ClearTz() *EarthquakeUpdateOne {
	euo.mutation.ClearTz()
	return euo
}

// SetURL sets the "url" field.
func (euo *EarthquakeUpdateOne) SetURL(s string) *EarthquakeUpdateOne {
	euo.mutation.SetURL(s)
	return euo
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableURL(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetURL(*s)
	}
	return euo
}

// ClearURL clears the value of the "url" field.
func (euo *EarthquakeUpdateOne) ClearURL() *EarthquakeUpdateOne {
	euo.mutation.ClearURL()
	return euo
}

// SetDetail sets the "detail" field.
func (euo *EarthquakeUpdateOne) SetDetail(s string) *EarthquakeUpdateOne {
	euo.mutation.SetDetail(s)
	return euo
}

// SetNillableDetail sets the "detail" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDetail(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetDetail(*s)
	}
	return euo
}

// ClearDetail clears the value of the "detail" field.
func (euo *EarthquakeUpdateOne) ClearDetail() *EarthquakeUpdateOne {
	euo.mutation.ClearDetail()
	return euo
}

// SetStatus sets the "status" field.
func (euo *EarthquakeUpdateOne) SetStatus(s string) *EarthquakeUpdateOne {
	euo.mutation.SetStatus(s)
	return euo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableStatus(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetStatus(*s)
	}
	return euo
}

// ClearStatus clears the value of the "status" field.
func (euo *EarthquakeUpdateOne) ClearStatus() *EarthquakeUpdateOne {
	euo.mutation.ClearStatus()
	return euo
}

// SetTsunami sets the "tsunami" field.
func (euo *EarthquakeUpdateOne) SetTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetTsunami()
	euo.mutation.SetTsunami(i)
	return euo
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTsunami(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetTsunami(*i)
	}
	return euo
}

// AddTsunami adds i to the "tsunami" field.
func (euo *EarthquakeUpdateOne) AddTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddTsunami(i)
	return euo
}

// ClearTsunami clears the value of the "tsunami" field.
func (euo *EarthquakeUpdateOne) ClearTsunami() *EarthquakeUpdateOne {
	euo.mutation.ClearTsunami()
	return euo
}

// SetSig sets the "sig" field.
func (euo *EarthquakeUpdateOne) SetSig(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetSig()
	euo.mutation.SetSig(i)
	return euo
}

// SetNillableSig sets the "sig" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableSig(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetSig(*i)
	}
	return euo
}

// AddSig adds i to the "sig" field.
func (euo *EarthquakeUpdateOne) AddSig(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddSig(i)
	return euo
}

// ClearSig clears the value of the "sig" field.
func (euo *EarthquakeUpdateOne) ClearSig() *EarthquakeUpdateOne {
	euo.mutation.ClearSig()
	return euo
}

// SetNet sets the "net" field.
func (euo *EarthquakeUpdateOne) SetNet(s string) *EarthquakeUpdateOne {
	euo.mutation.SetNet(s)
	return euo
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNet(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetNet(*s)
	}
	return euo
}

// ClearNet clears the value of the "net" field.
func (euo *EarthquakeUpdateOne) ClearNet() *EarthquakeUpdateOne {
	euo.mutation.ClearNet()
	return euo
}

// SetCode sets the "code" field.
func (euo *EarthquakeUpdateOne) SetCode(s string) *EarthquakeUpdateOne {
	euo.mutation.SetCode(s)
	return euo
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableCode(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetCode(*s)
	}
	return euo
}

// ClearCode clears the value of the "code" field.
func (euo *EarthquakeUpdateOne) ClearCode() *EarthquakeUpdateOne {
	euo.mutation.ClearCode()
	return euo
}

// SetNst sets the "nst" field.
func (euo *EarthquakeUpdateOne) SetNst(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetNst()
	euo.mutation.SetNst(i)
	return euo
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNst(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetNst(*i)
	}
	return euo
}

// AddNst adds i to the "nst" field.
func (euo *EarthquakeUpdateOne) AddNst(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddNst(i)
	return euo
}

// ClearNst clears the value of the "nst" field.
func (euo *EarthquakeUpdateOne) ClearNst() *EarthquakeUpdateOne {
	euo.mutation.ClearNst()
	return euo
}

// SetDmin sets the "dmin" field.
func (euo *EarthquakeUpdateOne) SetDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetDmin()
	euo.mutation.SetDmin(f)
	return euo
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDmin(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetDmin(*f)
	}
	return euo
}

// AddDmin adds f to the "dmin" field.
func (euo *EarthquakeUpdateOne) AddDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddDmin(f)
	return euo
}

// ClearDmin clears the value of the "dmin" field.
func (euo *EarthquakeUpdateOne) ClearDmin() *EarthquakeUpdateOne {
	euo.mutation.ClearDmin()
	return euo
}

// SetRms sets the "rms" field.
func (euo *EarthquakeUpdateOne) SetRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetRms()
	euo.mutation.SetRms(f)
	return euo
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableRms(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetRms(*f)
	}
	return euo
}

// AddRms adds f to the "rms" field.
func (euo *EarthquakeUpdateOne) AddRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddRms(f)
	return euo
}

// ClearRms clears the value of the "rms" field.
func (euo *EarthquakeUpdateOne) ClearRms() *EarthquakeUpdateOne {
	euo.mutation.ClearRms()
	return euo
}

// SetGap sets the "gap" field.
func (euo *EarthquakeUpdateOne) SetGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetGap()
	euo.mutation.SetGap(f)
	return euo
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableGap(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetGap(*f)
	}
	return euo
}

// AddGap adds f to the "gap" field.
func (euo *EarthquakeUpdateOne) AddGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddGap(f)
	return euo
}

// ClearGap clears the value of the "gap" field.
func (euo *EarthquakeUpdateOne) ClearGap() *EarthquakeUpdateOne {
	euo.mutation.ClearGap()
	return euo
}

// SetMagType sets the "mag_type" field.
func (euo *EarthquakeUpdateOne) SetMagType(s string) *EarthquakeUpdateOne {
	euo.mutation.SetMagType(s)
	return euo
}

// SetNillableMagType sets the "mag_type" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMagType(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetMagType(*s)
	}
	return euo
}

// ClearMagType clears the value of the "mag_type" field.
func (euo *EarthquakeUpdateOne) ClearMagType() *EarthquakeUpdateOne {
	euo.mutation.ClearMagType()
	return euo
}

// SetEqType sets the "eq_type" field.
func (euo *EarthquakeUpdateOne) SetEqType(s string) *EarthquakeUpdateOne {
	euo.mutation.SetEqType(s)
	return euo
}

// SetNillableEqType sets the "eq_type" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableEqType(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetEqType(*s)
	}
	return euo
}

// ClearEqType clears the value of the "eq_type" field.
func (euo *EarthquakeUpdateOne) ClearEqType() *EarthquakeUpdateOne {
	euo.mutation.ClearEqType()
	return euo
}

// SetCreatedAt sets the "created_at" field.
func (euo *EarthquakeUpdateOne) SetCreatedAt(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetCreatedAt(t)
	return euo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableCreatedAt(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetCreatedAt(*t)
	}
	return euo
}

// SetUpdatedAt sets the "updated_at" field.
func (euo *EarthquakeUpdateOne) SetUpdatedAt(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetUpdatedAt(t)
	return euo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableUpdatedAt(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetUpdatedAt(*t)
	}
	return euo
}

// SetDeletedAt sets the "deleted_at" field.
func (euo *EarthquakeUpdateOne) SetDeletedAt(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetDeletedAt(t)
	return euo
}

// SetNillableDeletedAt sets the "deleted_at" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDeletedAt(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetDeletedAt(*t)
	}
	return euo
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (euo *EarthquakeUpdateOne) ClearDeletedAt() *EarthquakeUpdateOne {
	euo.mutation.ClearDeletedAt()
	return euo
}

// SetGeometryID sets the "geometry" edge to the Geometry entity by ID.
func (euo *EarthquakeUpdateOne) SetGeometryID(id int) *EarthquakeUpdateOne {
	euo.mutation.SetGeometryID(id)
	return euo
}

// SetNillableGeometryID sets the "geometry" edge to the Geometry entity by ID if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableGeometryID(id *int) *EarthquakeUpdateOne {
	if id != nil {
		euo = euo.SetGeometryID(*id)
	}
	return euo
}

// SetGeometry sets the "geometry" edge to the Geometry entity.
func (euo *EarthquakeUpdateOne) SetGeometry(g *Geometry) *EarthquakeUpdateOne {
	return euo.SetGeometryID(g.ID)
}

// SetReport sets the "report" edge to the Report entity.
func (euo *EarthquakeUpdateOne) SetReport(r *Report) *EarthquakeUpdateOne {
	return euo.SetReportID(r.ID)
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (euo *EarthquakeUpdateOne) AddFtypeEarthquakeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.AddFtypeEarthquakeIDs(ids...)
	return euo
}

// AddFtypeEarthquakes adds the "ftype_earthquakes" edges to the FtypeEarthquake entity.
func (euo *EarthquakeUpdateOne) AddFtypeEarthquakes(f ...*FtypeEarthquake) *EarthquakeUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.AddFtypeEarthquakeIDs(ids...)
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (euo *EarthquakeUpdateOne) AddSourceEarthquakeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.AddSourceEarthquakeIDs(ids...)
	return euo
}

// AddSourceEarthquakes adds the "source_earthquakes" edges to the SourceEarthquake entity.
func (euo *EarthquakeUpdateOne) AddSourceEarthquakes(s ...*SourceEarthquake) *EarthquakeUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return euo.AddSourceEarthquakeIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (euo *EarthquakeUpdateOne) Mutation() *EarthquakeMutation {
	return euo.mutation
}

// ClearGeometry clears the "geometry" edge to the Geometry entity.
func (euo *EarthquakeUpdateOne) ClearGeometry() *EarthquakeUpdateOne {
	euo.mutation.ClearGeometry()
	return euo
}

// ClearReport clears the "report" edge to the Report entity.
func (euo *EarthquakeUpdateOne) ClearReport() *EarthquakeUpdateOne {
	euo.mutation.ClearReport()
	return euo
}

// ClearFtypeEarthquakes clears all "ftype_earthquakes" edges to the FtypeEarthquake entity.
func (euo *EarthquakeUpdateOne) ClearFtypeEarthquakes() *EarthquakeUpdateOne {
	euo.mutation.ClearFtypeEarthquakes()
	return euo
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to FtypeEarthquake entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveFtypeEarthquakeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.RemoveFtypeEarthquakeIDs(ids...)
	return euo
}

// RemoveFtypeEarthquakes removes "ftype_earthquakes" edges to FtypeEarthquake entities.
func (euo *EarthquakeUpdateOne) RemoveFtypeEarthquakes(f ...*FtypeEarthquake) *EarthquakeUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return euo.RemoveFtypeEarthquakeIDs(ids...)
}

// ClearSourceEarthquakes clears all "source_earthquakes" edges to the SourceEarthquake entity.
func (euo *EarthquakeUpdateOne) ClearSourceEarthquakes() *EarthquakeUpdateOne {
	euo.mutation.ClearSourceEarthquakes()
	return euo
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to SourceEarthquake entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveSourceEarthquakeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.RemoveSourceEarthquakeIDs(ids...)
	return euo
}

// RemoveSourceEarthquakes removes "source_earthquakes" edges to SourceEarthquake entities.
func (euo *EarthquakeUpdateOne) RemoveSourceEarthquakes(s ...*SourceEarthquake) *EarthquakeUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return euo.RemoveSourceEarthquakeIDs(ids...)
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (euo *EarthquakeUpdateOne) Where(ps ...predicate.Earthquake) *EarthquakeUpdateOne {
	euo.mutation.Where(ps...)
	return euo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (euo *EarthquakeUpdateOne) Select(field string, fields ...string) *EarthquakeUpdateOne {
	euo.fields = append([]string{field}, fields...)
	return euo
}

// Save executes the query and returns the updated Earthquake entity.
func (euo *EarthquakeUpdateOne) Save(ctx context.Context) (*Earthquake, error) {
	return withHooks(ctx, euo.sqlSave, euo.mutation, euo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) SaveX(ctx context.Context) *Earthquake {
	node, err := euo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (euo *EarthquakeUpdateOne) Exec(ctx context.Context) error {
	_, err := euo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) ExecX(ctx context.Context) {
	if err := euo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (euo *EarthquakeUpdateOne) sqlSave(ctx context.Context) (_node *Earthquake, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt))
	id, ok := euo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Earthquake.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := euo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, earthquake.FieldID)
		for _, f := range fields {
			if !earthquake.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != earthquake.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := euo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := euo.mutation.Mag(); ok {
		_spec.SetField(earthquake.FieldMag, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedMag(); ok {
		_spec.AddField(earthquake.FieldMag, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.Time(); ok {
		_spec.SetField(earthquake.FieldTime, field.TypeTime, value)
	}
	if value, ok := euo.mutation.UpdatedTime(); ok {
		_spec.SetField(earthquake.FieldUpdatedTime, field.TypeTime, value)
	}
	if euo.mutation.UpdatedTimeCleared() {
		_spec.ClearField(earthquake.FieldUpdatedTime, field.TypeTime)
	}
	if value, ok := euo.mutation.Tz(); ok {
		_spec.SetField(earthquake.FieldTz, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedTz(); ok {
		_spec.AddField(earthquake.FieldTz, field.TypeInt32, value)
	}
	if euo.mutation.TzCleared() {
		_spec.ClearField(earthquake.FieldTz, field.TypeInt32)
	}
	if value, ok := euo.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if euo.mutation.URLCleared() {
		_spec.ClearField(earthquake.FieldURL, field.TypeString)
	}
	if value, ok := euo.mutation.Detail(); ok {
		_spec.SetField(earthquake.FieldDetail, field.TypeString, value)
	}
	if euo.mutation.DetailCleared() {
		_spec.ClearField(earthquake.FieldDetail, field.TypeString)
	}
	if value, ok := euo.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if euo.mutation.StatusCleared() {
		_spec.ClearField(earthquake.FieldStatus, field.TypeString)
	}
	if value, ok := euo.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if euo.mutation.TsunamiCleared() {
		_spec.ClearField(earthquake.FieldTsunami, field.TypeInt32)
	}
	if value, ok := euo.mutation.Sig(); ok {
		_spec.SetField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedSig(); ok {
		_spec.AddField(earthquake.FieldSig, field.TypeInt32, value)
	}
	if euo.mutation.SigCleared() {
		_spec.ClearField(earthquake.FieldSig, field.TypeInt32)
	}
	if value, ok := euo.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if euo.mutation.NetCleared() {
		_spec.ClearField(earthquake.FieldNet, field.TypeString)
	}
	if value, ok := euo.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if euo.mutation.CodeCleared() {
		_spec.ClearField(earthquake.FieldCode, field.TypeString)
	}
	if value, ok := euo.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt32, value)
	}
	if euo.mutation.NstCleared() {
		_spec.ClearField(earthquake.FieldNst, field.TypeInt32)
	}
	if value, ok := euo.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if euo.mutation.DminCleared() {
		_spec.ClearField(earthquake.FieldDmin, field.TypeFloat64)
	}
	if value, ok := euo.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if euo.mutation.RmsCleared() {
		_spec.ClearField(earthquake.FieldRms, field.TypeFloat64)
	}
	if value, ok := euo.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if euo.mutation.GapCleared() {
		_spec.ClearField(earthquake.FieldGap, field.TypeFloat64)
	}
	if value, ok := euo.mutation.MagType(); ok {
		_spec.SetField(earthquake.FieldMagType, field.TypeString, value)
	}
	if euo.mutation.MagTypeCleared() {
		_spec.ClearField(earthquake.FieldMagType, field.TypeString)
	}
	if value, ok := euo.mutation.EqType(); ok {
		_spec.SetField(earthquake.FieldEqType, field.TypeString, value)
	}
	if euo.mutation.EqTypeCleared() {
		_spec.ClearField(earthquake.FieldEqType, field.TypeString)
	}
	if value, ok := euo.mutation.CreatedAt(); ok {
		_spec.SetField(earthquake.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := euo.mutation.UpdatedAt(); ok {
		_spec.SetField(earthquake.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := euo.mutation.DeletedAt(); ok {
		_spec.SetField(earthquake.FieldDeletedAt, field.TypeTime, value)
	}
	if euo.mutation.DeletedAtCleared() {
		_spec.ClearField(earthquake.FieldDeletedAt, field.TypeTime)
	}
	if euo.mutation.GeometryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.GeometryTable,
			Columns: []string{earthquake.GeometryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.GeometryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.GeometryTable,
			Columns: []string{earthquake.GeometryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(geometry.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.ReportCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.ReportTable,
			Columns: []string{earthquake.ReportColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(report.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.ReportIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.ReportTable,
			Columns: []string{earthquake.ReportColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(report.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.FtypeEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedFtypeEarthquakesIDs(); len(nodes) > 0 && !euo.mutation.FtypeEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.FtypeEarthquakesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.FtypeEarthquakesTable,
			Columns: []string{earthquake.FtypeEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(ftypeearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.SourceEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedSourceEarthquakesIDs(); len(nodes) > 0 && !euo.mutation.SourceEarthquakesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.SourceEarthquakesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.SourceEarthquakesTable,
			Columns: []string{earthquake.SourceEarthquakesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sourceearthquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Earthquake{config: euo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, euo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	euo.mutation.done = true
	return _node, nil
}
