// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"gitlab.com/hedwig-phan/assignment-3/ent/apireq"
	"gitlab.com/hedwig-phan/assignment-3/ent/credentials"
	"gitlab.com/hedwig-phan/assignment-3/ent/earthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/featuretype"
	"gitlab.com/hedwig-phan/assignment-3/ent/ftypeearthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/geometry"
	"gitlab.com/hedwig-phan/assignment-3/ent/location"
	"gitlab.com/hedwig-phan/assignment-3/ent/passwordresetrequest"
	"gitlab.com/hedwig-phan/assignment-3/ent/predicate"
	"gitlab.com/hedwig-phan/assignment-3/ent/report"
	"gitlab.com/hedwig-phan/assignment-3/ent/session"
	"gitlab.com/hedwig-phan/assignment-3/ent/source"
	"gitlab.com/hedwig-phan/assignment-3/ent/sourceearthquake"
	"gitlab.com/hedwig-phan/assignment-3/ent/token"
	"gitlab.com/hedwig-phan/assignment-3/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApireq               = "Apireq"
	TypeCredentials          = "Credentials"
	TypeEarthquake           = "Earthquake"
	TypeFeatureType          = "FeatureType"
	TypeFtypeEarthquake      = "FtypeEarthquake"
	TypeGeometry             = "Geometry"
	TypeLocation             = "Location"
	TypePasswordResetRequest = "PasswordResetRequest"
	TypeReport               = "Report"
	TypeSession              = "Session"
	TypeSource               = "Source"
	TypeSourceEarthquake     = "SourceEarthquake"
	TypeToken                = "Token"
	TypeUser                 = "User"
)

// ApireqMutation represents an operation that mutates the Apireq nodes in the graph.
type ApireqMutation struct {
	config
	op             Op
	typ            string
	id             *int
	req_time       *time.Time
	req_param      *map[string]interface{}
	req_body       *map[string]interface{}
	req_headers    *map[string]interface{}
	req_metadata   *map[string]interface{}
	resp_time      *time.Time
	resp_status    *int
	addresp_status *int
	resp_body      *map[string]interface{}
	resp_headers   *map[string]interface{}
	resp_metadata  *map[string]interface{}
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Apireq, error)
	predicates     []predicate.Apireq
}

var _ ent.Mutation = (*ApireqMutation)(nil)

// apireqOption allows management of the mutation configuration using functional options.
type apireqOption func(*ApireqMutation)

// newApireqMutation creates new mutation for the Apireq entity.
func newApireqMutation(c config, op Op, opts ...apireqOption) *ApireqMutation {
	m := &ApireqMutation{
		config:        c,
		op:            op,
		typ:           TypeApireq,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApireqID sets the ID field of the mutation.
func withApireqID(id int) apireqOption {
	return func(m *ApireqMutation) {
		var (
			err   error
			once  sync.Once
			value *Apireq
		)
		m.oldValue = func(ctx context.Context) (*Apireq, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Apireq.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApireq sets the old Apireq of the mutation.
func withApireq(node *Apireq) apireqOption {
	return func(m *ApireqMutation) {
		m.oldValue = func(context.Context) (*Apireq, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApireqMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApireqMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Apireq entities.
func (m *ApireqMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApireqMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApireqMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Apireq.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReqTime sets the "req_time" field.
func (m *ApireqMutation) SetReqTime(t time.Time) {
	m.req_time = &t
}

// ReqTime returns the value of the "req_time" field in the mutation.
func (m *ApireqMutation) ReqTime() (r time.Time, exists bool) {
	v := m.req_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReqTime returns the old "req_time" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqTime: %w", err)
	}
	return oldValue.ReqTime, nil
}

// ResetReqTime resets all changes to the "req_time" field.
func (m *ApireqMutation) ResetReqTime() {
	m.req_time = nil
}

// SetReqParam sets the "req_param" field.
func (m *ApireqMutation) SetReqParam(value map[string]interface{}) {
	m.req_param = &value
}

// ReqParam returns the value of the "req_param" field in the mutation.
func (m *ApireqMutation) ReqParam() (r map[string]interface{}, exists bool) {
	v := m.req_param
	if v == nil {
		return
	}
	return *v, true
}

// OldReqParam returns the old "req_param" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqParam(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqParam: %w", err)
	}
	return oldValue.ReqParam, nil
}

// ClearReqParam clears the value of the "req_param" field.
func (m *ApireqMutation) ClearReqParam() {
	m.req_param = nil
	m.clearedFields[apireq.FieldReqParam] = struct{}{}
}

// ReqParamCleared returns if the "req_param" field was cleared in this mutation.
func (m *ApireqMutation) ReqParamCleared() bool {
	_, ok := m.clearedFields[apireq.FieldReqParam]
	return ok
}

// ResetReqParam resets all changes to the "req_param" field.
func (m *ApireqMutation) ResetReqParam() {
	m.req_param = nil
	delete(m.clearedFields, apireq.FieldReqParam)
}

// SetReqBody sets the "req_body" field.
func (m *ApireqMutation) SetReqBody(value map[string]interface{}) {
	m.req_body = &value
}

// ReqBody returns the value of the "req_body" field in the mutation.
func (m *ApireqMutation) ReqBody() (r map[string]interface{}, exists bool) {
	v := m.req_body
	if v == nil {
		return
	}
	return *v, true
}

// OldReqBody returns the old "req_body" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqBody: %w", err)
	}
	return oldValue.ReqBody, nil
}

// ClearReqBody clears the value of the "req_body" field.
func (m *ApireqMutation) ClearReqBody() {
	m.req_body = nil
	m.clearedFields[apireq.FieldReqBody] = struct{}{}
}

// ReqBodyCleared returns if the "req_body" field was cleared in this mutation.
func (m *ApireqMutation) ReqBodyCleared() bool {
	_, ok := m.clearedFields[apireq.FieldReqBody]
	return ok
}

// ResetReqBody resets all changes to the "req_body" field.
func (m *ApireqMutation) ResetReqBody() {
	m.req_body = nil
	delete(m.clearedFields, apireq.FieldReqBody)
}

// SetReqHeaders sets the "req_headers" field.
func (m *ApireqMutation) SetReqHeaders(value map[string]interface{}) {
	m.req_headers = &value
}

// ReqHeaders returns the value of the "req_headers" field in the mutation.
func (m *ApireqMutation) ReqHeaders() (r map[string]interface{}, exists bool) {
	v := m.req_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldReqHeaders returns the old "req_headers" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqHeaders(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqHeaders: %w", err)
	}
	return oldValue.ReqHeaders, nil
}

// ClearReqHeaders clears the value of the "req_headers" field.
func (m *ApireqMutation) ClearReqHeaders() {
	m.req_headers = nil
	m.clearedFields[apireq.FieldReqHeaders] = struct{}{}
}

// ReqHeadersCleared returns if the "req_headers" field was cleared in this mutation.
func (m *ApireqMutation) ReqHeadersCleared() bool {
	_, ok := m.clearedFields[apireq.FieldReqHeaders]
	return ok
}

// ResetReqHeaders resets all changes to the "req_headers" field.
func (m *ApireqMutation) ResetReqHeaders() {
	m.req_headers = nil
	delete(m.clearedFields, apireq.FieldReqHeaders)
}

// SetReqMetadata sets the "req_metadata" field.
func (m *ApireqMutation) SetReqMetadata(value map[string]interface{}) {
	m.req_metadata = &value
}

// ReqMetadata returns the value of the "req_metadata" field in the mutation.
func (m *ApireqMutation) ReqMetadata() (r map[string]interface{}, exists bool) {
	v := m.req_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldReqMetadata returns the old "req_metadata" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqMetadata: %w", err)
	}
	return oldValue.ReqMetadata, nil
}

// ClearReqMetadata clears the value of the "req_metadata" field.
func (m *ApireqMutation) ClearReqMetadata() {
	m.req_metadata = nil
	m.clearedFields[apireq.FieldReqMetadata] = struct{}{}
}

// ReqMetadataCleared returns if the "req_metadata" field was cleared in this mutation.
func (m *ApireqMutation) ReqMetadataCleared() bool {
	_, ok := m.clearedFields[apireq.FieldReqMetadata]
	return ok
}

// ResetReqMetadata resets all changes to the "req_metadata" field.
func (m *ApireqMutation) ResetReqMetadata() {
	m.req_metadata = nil
	delete(m.clearedFields, apireq.FieldReqMetadata)
}

// SetRespTime sets the "resp_time" field.
func (m *ApireqMutation) SetRespTime(t time.Time) {
	m.resp_time = &t
}

// RespTime returns the value of the "resp_time" field in the mutation.
func (m *ApireqMutation) RespTime() (r time.Time, exists bool) {
	v := m.resp_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRespTime returns the old "resp_time" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldRespTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespTime: %w", err)
	}
	return oldValue.RespTime, nil
}

// ResetRespTime resets all changes to the "resp_time" field.
func (m *ApireqMutation) ResetRespTime() {
	m.resp_time = nil
}

// SetRespStatus sets the "resp_status" field.
func (m *ApireqMutation) SetRespStatus(i int) {
	m.resp_status = &i
	m.addresp_status = nil
}

// RespStatus returns the value of the "resp_status" field in the mutation.
func (m *ApireqMutation) RespStatus() (r int, exists bool) {
	v := m.resp_status
	if v == nil {
		return
	}
	return *v, true
}

// OldRespStatus returns the old "resp_status" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldRespStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespStatus: %w", err)
	}
	return oldValue.RespStatus, nil
}

// AddRespStatus adds i to the "resp_status" field.
func (m *ApireqMutation) AddRespStatus(i int) {
	if m.addresp_status != nil {
		*m.addresp_status += i
	} else {
		m.addresp_status = &i
	}
}

// AddedRespStatus returns the value that was added to the "resp_status" field in this mutation.
func (m *ApireqMutation) AddedRespStatus() (r int, exists bool) {
	v := m.addresp_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearRespStatus clears the value of the "resp_status" field.
func (m *ApireqMutation) ClearRespStatus() {
	m.resp_status = nil
	m.addresp_status = nil
	m.clearedFields[apireq.FieldRespStatus] = struct{}{}
}

// RespStatusCleared returns if the "resp_status" field was cleared in this mutation.
func (m *ApireqMutation) RespStatusCleared() bool {
	_, ok := m.clearedFields[apireq.FieldRespStatus]
	return ok
}

// ResetRespStatus resets all changes to the "resp_status" field.
func (m *ApireqMutation) ResetRespStatus() {
	m.resp_status = nil
	m.addresp_status = nil
	delete(m.clearedFields, apireq.FieldRespStatus)
}

// SetRespBody sets the "resp_body" field.
func (m *ApireqMutation) SetRespBody(value map[string]interface{}) {
	m.resp_body = &value
}

// RespBody returns the value of the "resp_body" field in the mutation.
func (m *ApireqMutation) RespBody() (r map[string]interface{}, exists bool) {
	v := m.resp_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRespBody returns the old "resp_body" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldRespBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespBody: %w", err)
	}
	return oldValue.RespBody, nil
}

// ClearRespBody clears the value of the "resp_body" field.
func (m *ApireqMutation) ClearRespBody() {
	m.resp_body = nil
	m.clearedFields[apireq.FieldRespBody] = struct{}{}
}

// RespBodyCleared returns if the "resp_body" field was cleared in this mutation.
func (m *ApireqMutation) RespBodyCleared() bool {
	_, ok := m.clearedFields[apireq.FieldRespBody]
	return ok
}

// ResetRespBody resets all changes to the "resp_body" field.
func (m *ApireqMutation) ResetRespBody() {
	m.resp_body = nil
	delete(m.clearedFields, apireq.FieldRespBody)
}

// SetRespHeaders sets the "resp_headers" field.
func (m *ApireqMutation) SetRespHeaders(value map[string]interface{}) {
	m.resp_headers = &value
}

// RespHeaders returns the value of the "resp_headers" field in the mutation.
func (m *ApireqMutation) RespHeaders() (r map[string]interface{}, exists bool) {
	v := m.resp_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRespHeaders returns the old "resp_headers" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldRespHeaders(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespHeaders: %w", err)
	}
	return oldValue.RespHeaders, nil
}

// ClearRespHeaders clears the value of the "resp_headers" field.
func (m *ApireqMutation) ClearRespHeaders() {
	m.resp_headers = nil
	m.clearedFields[apireq.FieldRespHeaders] = struct{}{}
}

// RespHeadersCleared returns if the "resp_headers" field was cleared in this mutation.
func (m *ApireqMutation) RespHeadersCleared() bool {
	_, ok := m.clearedFields[apireq.FieldRespHeaders]
	return ok
}

// ResetRespHeaders resets all changes to the "resp_headers" field.
func (m *ApireqMutation) ResetRespHeaders() {
	m.resp_headers = nil
	delete(m.clearedFields, apireq.FieldRespHeaders)
}

// SetRespMetadata sets the "resp_metadata" field.
func (m *ApireqMutation) SetRespMetadata(value map[string]interface{}) {
	m.resp_metadata = &value
}

// RespMetadata returns the value of the "resp_metadata" field in the mutation.
func (m *ApireqMutation) RespMetadata() (r map[string]interface{}, exists bool) {
	v := m.resp_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldRespMetadata returns the old "resp_metadata" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldRespMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespMetadata: %w", err)
	}
	return oldValue.RespMetadata, nil
}

// ClearRespMetadata clears the value of the "resp_metadata" field.
func (m *ApireqMutation) ClearRespMetadata() {
	m.resp_metadata = nil
	m.clearedFields[apireq.FieldRespMetadata] = struct{}{}
}

// RespMetadataCleared returns if the "resp_metadata" field was cleared in this mutation.
func (m *ApireqMutation) RespMetadataCleared() bool {
	_, ok := m.clearedFields[apireq.FieldRespMetadata]
	return ok
}

// ResetRespMetadata resets all changes to the "resp_metadata" field.
func (m *ApireqMutation) ResetRespMetadata() {
	m.resp_metadata = nil
	delete(m.clearedFields, apireq.FieldRespMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *ApireqMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApireqMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApireqMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApireqMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApireqMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApireqMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApireqMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApireqMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApireqMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apireq.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApireqMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apireq.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApireqMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apireq.FieldDeletedAt)
}

// Where appends a list predicates to the ApireqMutation builder.
func (m *ApireqMutation) Where(ps ...predicate.Apireq) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApireqMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApireqMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Apireq, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApireqMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApireqMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Apireq).
func (m *ApireqMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApireqMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.req_time != nil {
		fields = append(fields, apireq.FieldReqTime)
	}
	if m.req_param != nil {
		fields = append(fields, apireq.FieldReqParam)
	}
	if m.req_body != nil {
		fields = append(fields, apireq.FieldReqBody)
	}
	if m.req_headers != nil {
		fields = append(fields, apireq.FieldReqHeaders)
	}
	if m.req_metadata != nil {
		fields = append(fields, apireq.FieldReqMetadata)
	}
	if m.resp_time != nil {
		fields = append(fields, apireq.FieldRespTime)
	}
	if m.resp_status != nil {
		fields = append(fields, apireq.FieldRespStatus)
	}
	if m.resp_body != nil {
		fields = append(fields, apireq.FieldRespBody)
	}
	if m.resp_headers != nil {
		fields = append(fields, apireq.FieldRespHeaders)
	}
	if m.resp_metadata != nil {
		fields = append(fields, apireq.FieldRespMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, apireq.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apireq.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apireq.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApireqMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apireq.FieldReqTime:
		return m.ReqTime()
	case apireq.FieldReqParam:
		return m.ReqParam()
	case apireq.FieldReqBody:
		return m.ReqBody()
	case apireq.FieldReqHeaders:
		return m.ReqHeaders()
	case apireq.FieldReqMetadata:
		return m.ReqMetadata()
	case apireq.FieldRespTime:
		return m.RespTime()
	case apireq.FieldRespStatus:
		return m.RespStatus()
	case apireq.FieldRespBody:
		return m.RespBody()
	case apireq.FieldRespHeaders:
		return m.RespHeaders()
	case apireq.FieldRespMetadata:
		return m.RespMetadata()
	case apireq.FieldCreatedAt:
		return m.CreatedAt()
	case apireq.FieldUpdatedAt:
		return m.UpdatedAt()
	case apireq.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApireqMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apireq.FieldReqTime:
		return m.OldReqTime(ctx)
	case apireq.FieldReqParam:
		return m.OldReqParam(ctx)
	case apireq.FieldReqBody:
		return m.OldReqBody(ctx)
	case apireq.FieldReqHeaders:
		return m.OldReqHeaders(ctx)
	case apireq.FieldReqMetadata:
		return m.OldReqMetadata(ctx)
	case apireq.FieldRespTime:
		return m.OldRespTime(ctx)
	case apireq.FieldRespStatus:
		return m.OldRespStatus(ctx)
	case apireq.FieldRespBody:
		return m.OldRespBody(ctx)
	case apireq.FieldRespHeaders:
		return m.OldRespHeaders(ctx)
	case apireq.FieldRespMetadata:
		return m.OldRespMetadata(ctx)
	case apireq.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apireq.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apireq.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Apireq field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApireqMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apireq.FieldReqTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqTime(v)
		return nil
	case apireq.FieldReqParam:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqParam(v)
		return nil
	case apireq.FieldReqBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqBody(v)
		return nil
	case apireq.FieldReqHeaders:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqHeaders(v)
		return nil
	case apireq.FieldReqMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqMetadata(v)
		return nil
	case apireq.FieldRespTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespTime(v)
		return nil
	case apireq.FieldRespStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespStatus(v)
		return nil
	case apireq.FieldRespBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespBody(v)
		return nil
	case apireq.FieldRespHeaders:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespHeaders(v)
		return nil
	case apireq.FieldRespMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespMetadata(v)
		return nil
	case apireq.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apireq.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apireq.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Apireq field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApireqMutation) AddedFields() []string {
	var fields []string
	if m.addresp_status != nil {
		fields = append(fields, apireq.FieldRespStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApireqMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apireq.FieldRespStatus:
		return m.AddedRespStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApireqMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apireq.FieldRespStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Apireq numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApireqMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apireq.FieldReqParam) {
		fields = append(fields, apireq.FieldReqParam)
	}
	if m.FieldCleared(apireq.FieldReqBody) {
		fields = append(fields, apireq.FieldReqBody)
	}
	if m.FieldCleared(apireq.FieldReqHeaders) {
		fields = append(fields, apireq.FieldReqHeaders)
	}
	if m.FieldCleared(apireq.FieldReqMetadata) {
		fields = append(fields, apireq.FieldReqMetadata)
	}
	if m.FieldCleared(apireq.FieldRespStatus) {
		fields = append(fields, apireq.FieldRespStatus)
	}
	if m.FieldCleared(apireq.FieldRespBody) {
		fields = append(fields, apireq.FieldRespBody)
	}
	if m.FieldCleared(apireq.FieldRespHeaders) {
		fields = append(fields, apireq.FieldRespHeaders)
	}
	if m.FieldCleared(apireq.FieldRespMetadata) {
		fields = append(fields, apireq.FieldRespMetadata)
	}
	if m.FieldCleared(apireq.FieldDeletedAt) {
		fields = append(fields, apireq.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApireqMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApireqMutation) ClearField(name string) error {
	switch name {
	case apireq.FieldReqParam:
		m.ClearReqParam()
		return nil
	case apireq.FieldReqBody:
		m.ClearReqBody()
		return nil
	case apireq.FieldReqHeaders:
		m.ClearReqHeaders()
		return nil
	case apireq.FieldReqMetadata:
		m.ClearReqMetadata()
		return nil
	case apireq.FieldRespStatus:
		m.ClearRespStatus()
		return nil
	case apireq.FieldRespBody:
		m.ClearRespBody()
		return nil
	case apireq.FieldRespHeaders:
		m.ClearRespHeaders()
		return nil
	case apireq.FieldRespMetadata:
		m.ClearRespMetadata()
		return nil
	case apireq.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Apireq nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApireqMutation) ResetField(name string) error {
	switch name {
	case apireq.FieldReqTime:
		m.ResetReqTime()
		return nil
	case apireq.FieldReqParam:
		m.ResetReqParam()
		return nil
	case apireq.FieldReqBody:
		m.ResetReqBody()
		return nil
	case apireq.FieldReqHeaders:
		m.ResetReqHeaders()
		return nil
	case apireq.FieldReqMetadata:
		m.ResetReqMetadata()
		return nil
	case apireq.FieldRespTime:
		m.ResetRespTime()
		return nil
	case apireq.FieldRespStatus:
		m.ResetRespStatus()
		return nil
	case apireq.FieldRespBody:
		m.ResetRespBody()
		return nil
	case apireq.FieldRespHeaders:
		m.ResetRespHeaders()
		return nil
	case apireq.FieldRespMetadata:
		m.ResetRespMetadata()
		return nil
	case apireq.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apireq.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apireq.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Apireq field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApireqMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApireqMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApireqMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApireqMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApireqMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApireqMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApireqMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Apireq unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApireqMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Apireq edge %s", name)
}

// CredentialsMutation represents an operation that mutates the Credentials nodes in the graph.
type CredentialsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	hashed_password *string
	last_login      *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Credentials, error)
	predicates      []predicate.Credentials
}

var _ ent.Mutation = (*CredentialsMutation)(nil)

// credentialsOption allows management of the mutation configuration using functional options.
type credentialsOption func(*CredentialsMutation)

// newCredentialsMutation creates new mutation for the Credentials entity.
func newCredentialsMutation(c config, op Op, opts ...credentialsOption) *CredentialsMutation {
	m := &CredentialsMutation{
		config:        c,
		op:            op,
		typ:           TypeCredentials,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialsID sets the ID field of the mutation.
func withCredentialsID(id int) credentialsOption {
	return func(m *CredentialsMutation) {
		var (
			err   error
			once  sync.Once
			value *Credentials
		)
		m.oldValue = func(ctx context.Context) (*Credentials, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credentials.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredentials sets the old Credentials of the mutation.
func withCredentials(node *Credentials) credentialsOption {
	return func(m *CredentialsMutation) {
		m.oldValue = func(context.Context) (*Credentials, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CredentialsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Credentials.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CredentialsMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CredentialsMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CredentialsMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[credentials.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CredentialsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[credentials.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CredentialsMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, credentials.FieldUserID)
}

// SetHashedPassword sets the "hashed_password" field.
func (m *CredentialsMutation) SetHashedPassword(s string) {
	m.hashed_password = &s
}

// HashedPassword returns the value of the "hashed_password" field in the mutation.
func (m *CredentialsMutation) HashedPassword() (r string, exists bool) {
	v := m.hashed_password
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPassword returns the old "hashed_password" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldHashedPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPassword: %w", err)
	}
	return oldValue.HashedPassword, nil
}

// ResetHashedPassword resets all changes to the "hashed_password" field.
func (m *CredentialsMutation) ResetHashedPassword() {
	m.hashed_password = nil
}

// SetLastLogin sets the "last_login" field.
func (m *CredentialsMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *CredentialsMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the Credentials entity.
// If the Credentials object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialsMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *CredentialsMutation) ResetLastLogin() {
	m.last_login = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CredentialsMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[credentials.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CredentialsMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CredentialsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CredentialsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CredentialsMutation builder.
func (m *CredentialsMutation) Where(ps ...predicate.Credentials) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CredentialsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CredentialsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Credentials, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CredentialsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CredentialsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Credentials).
func (m *CredentialsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, credentials.FieldUserID)
	}
	if m.hashed_password != nil {
		fields = append(fields, credentials.FieldHashedPassword)
	}
	if m.last_login != nil {
		fields = append(fields, credentials.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credentials.FieldUserID:
		return m.UserID()
	case credentials.FieldHashedPassword:
		return m.HashedPassword()
	case credentials.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credentials.FieldUserID:
		return m.OldUserID(ctx)
	case credentials.FieldHashedPassword:
		return m.OldHashedPassword(ctx)
	case credentials.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown Credentials field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credentials.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credentials.FieldHashedPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPassword(v)
		return nil
	case credentials.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credentials numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credentials.FieldUserID) {
		fields = append(fields, credentials.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialsMutation) ClearField(name string) error {
	switch name {
	case credentials.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Credentials nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialsMutation) ResetField(name string) error {
	switch name {
	case credentials.FieldUserID:
		m.ResetUserID()
		return nil
	case credentials.FieldHashedPassword:
		m.ResetHashedPassword()
		return nil
	case credentials.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown Credentials field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credentials.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credentials.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credentials.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialsMutation) EdgeCleared(name string) bool {
	switch name {
	case credentials.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialsMutation) ClearEdge(name string) error {
	switch name {
	case credentials.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Credentials unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialsMutation) ResetEdge(name string) error {
	switch name {
	case credentials.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Credentials edge %s", name)
}

// EarthquakeMutation represents an operation that mutates the Earthquake nodes in the graph.
type EarthquakeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	mag                       *float64
	addmag                    *float64
	time                      *time.Time
	updated_time              *time.Time
	tz                        *int32
	addtz                     *int32
	url                       *string
	detail                    *string
	status                    *string
	tsunami                   *int32
	addtsunami                *int32
	sig                       *int32
	addsig                    *int32
	net                       *string
	code                      *string
	nst                       *int32
	addnst                    *int32
	dmin                      *float64
	adddmin                   *float64
	rms                       *float64
	addrms                    *float64
	gap                       *float64
	addgap                    *float64
	mag_type                  *string
	eq_type                   *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	geometry                  *int
	clearedgeometry           bool
	report                    *int
	clearedreport             bool
	ftype_earthquakes         map[int]struct{}
	removedftype_earthquakes  map[int]struct{}
	clearedftype_earthquakes  bool
	source_earthquakes        map[int]struct{}
	removedsource_earthquakes map[int]struct{}
	clearedsource_earthquakes bool
	done                      bool
	oldValue                  func(context.Context) (*Earthquake, error)
	predicates                []predicate.Earthquake
}

var _ ent.Mutation = (*EarthquakeMutation)(nil)

// earthquakeOption allows management of the mutation configuration using functional options.
type earthquakeOption func(*EarthquakeMutation)

// newEarthquakeMutation creates new mutation for the Earthquake entity.
func newEarthquakeMutation(c config, op Op, opts ...earthquakeOption) *EarthquakeMutation {
	m := &EarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarthquakeID sets the ID field of the mutation.
func withEarthquakeID(id int) earthquakeOption {
	return func(m *EarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Earthquake
		)
		m.oldValue = func(ctx context.Context) (*Earthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Earthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarthquake sets the old Earthquake of the mutation.
func withEarthquake(node *Earthquake) earthquakeOption {
	return func(m *EarthquakeMutation) {
		m.oldValue = func(context.Context) (*Earthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Earthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGeoID sets the "geo_id" field.
func (m *EarthquakeMutation) SetGeoID(i int) {
	m.geometry = &i
}

// GeoID returns the value of the "geo_id" field in the mutation.
func (m *EarthquakeMutation) GeoID() (r int, exists bool) {
	v := m.geometry
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoID returns the old "geo_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoID: %w", err)
	}
	return oldValue.GeoID, nil
}

// ClearGeoID clears the value of the "geo_id" field.
func (m *EarthquakeMutation) ClearGeoID() {
	m.geometry = nil
	m.clearedFields[earthquake.FieldGeoID] = struct{}{}
}

// GeoIDCleared returns if the "geo_id" field was cleared in this mutation.
func (m *EarthquakeMutation) GeoIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldGeoID]
	return ok
}

// ResetGeoID resets all changes to the "geo_id" field.
func (m *EarthquakeMutation) ResetGeoID() {
	m.geometry = nil
	delete(m.clearedFields, earthquake.FieldGeoID)
}

// SetReportID sets the "report_id" field.
func (m *EarthquakeMutation) SetReportID(i int) {
	m.report = &i
}

// ReportID returns the value of the "report_id" field in the mutation.
func (m *EarthquakeMutation) ReportID() (r int, exists bool) {
	v := m.report
	if v == nil {
		return
	}
	return *v, true
}

// OldReportID returns the old "report_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldReportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportID: %w", err)
	}
	return oldValue.ReportID, nil
}

// ClearReportID clears the value of the "report_id" field.
func (m *EarthquakeMutation) ClearReportID() {
	m.report = nil
	m.clearedFields[earthquake.FieldReportID] = struct{}{}
}

// ReportIDCleared returns if the "report_id" field was cleared in this mutation.
func (m *EarthquakeMutation) ReportIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldReportID]
	return ok
}

// ResetReportID resets all changes to the "report_id" field.
func (m *EarthquakeMutation) ResetReportID() {
	m.report = nil
	delete(m.clearedFields, earthquake.FieldReportID)
}

// SetMag sets the "mag" field.
func (m *EarthquakeMutation) SetMag(f float64) {
	m.mag = &f
	m.addmag = nil
}

// Mag returns the value of the "mag" field in the mutation.
func (m *EarthquakeMutation) Mag() (r float64, exists bool) {
	v := m.mag
	if v == nil {
		return
	}
	return *v, true
}

// OldMag returns the old "mag" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMag(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMag: %w", err)
	}
	return oldValue.Mag, nil
}

// AddMag adds f to the "mag" field.
func (m *EarthquakeMutation) AddMag(f float64) {
	if m.addmag != nil {
		*m.addmag += f
	} else {
		m.addmag = &f
	}
}

// AddedMag returns the value that was added to the "mag" field in this mutation.
func (m *EarthquakeMutation) AddedMag() (r float64, exists bool) {
	v := m.addmag
	if v == nil {
		return
	}
	return *v, true
}

// ResetMag resets all changes to the "mag" field.
func (m *EarthquakeMutation) ResetMag() {
	m.mag = nil
	m.addmag = nil
}

// SetTime sets the "time" field.
func (m *EarthquakeMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *EarthquakeMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *EarthquakeMutation) ResetTime() {
	m.time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *EarthquakeMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *EarthquakeMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *EarthquakeMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[earthquake.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *EarthquakeMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *EarthquakeMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, earthquake.FieldUpdatedTime)
}

// SetTz sets the "tz" field.
func (m *EarthquakeMutation) SetTz(i int32) {
	m.tz = &i
	m.addtz = nil
}

// Tz returns the value of the "tz" field in the mutation.
func (m *EarthquakeMutation) Tz() (r int32, exists bool) {
	v := m.tz
	if v == nil {
		return
	}
	return *v, true
}

// OldTz returns the old "tz" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTz(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTz is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTz requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTz: %w", err)
	}
	return oldValue.Tz, nil
}

// AddTz adds i to the "tz" field.
func (m *EarthquakeMutation) AddTz(i int32) {
	if m.addtz != nil {
		*m.addtz += i
	} else {
		m.addtz = &i
	}
}

// AddedTz returns the value that was added to the "tz" field in this mutation.
func (m *EarthquakeMutation) AddedTz() (r int32, exists bool) {
	v := m.addtz
	if v == nil {
		return
	}
	return *v, true
}

// ClearTz clears the value of the "tz" field.
func (m *EarthquakeMutation) ClearTz() {
	m.tz = nil
	m.addtz = nil
	m.clearedFields[earthquake.FieldTz] = struct{}{}
}

// TzCleared returns if the "tz" field was cleared in this mutation.
func (m *EarthquakeMutation) TzCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTz]
	return ok
}

// ResetTz resets all changes to the "tz" field.
func (m *EarthquakeMutation) ResetTz() {
	m.tz = nil
	m.addtz = nil
	delete(m.clearedFields, earthquake.FieldTz)
}

// SetURL sets the "url" field.
func (m *EarthquakeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EarthquakeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EarthquakeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[earthquake.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EarthquakeMutation) URLCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EarthquakeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, earthquake.FieldURL)
}

// SetDetail sets the "detail" field.
func (m *EarthquakeMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *EarthquakeMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *EarthquakeMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[earthquake.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *EarthquakeMutation) DetailCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *EarthquakeMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, earthquake.FieldDetail)
}

// SetStatus sets the "status" field.
func (m *EarthquakeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EarthquakeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EarthquakeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[earthquake.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EarthquakeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EarthquakeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, earthquake.FieldStatus)
}

// SetTsunami sets the "tsunami" field.
func (m *EarthquakeMutation) SetTsunami(i int32) {
	m.tsunami = &i
	m.addtsunami = nil
}

// Tsunami returns the value of the "tsunami" field in the mutation.
func (m *EarthquakeMutation) Tsunami() (r int32, exists bool) {
	v := m.tsunami
	if v == nil {
		return
	}
	return *v, true
}

// OldTsunami returns the old "tsunami" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTsunami(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTsunami is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTsunami requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTsunami: %w", err)
	}
	return oldValue.Tsunami, nil
}

// AddTsunami adds i to the "tsunami" field.
func (m *EarthquakeMutation) AddTsunami(i int32) {
	if m.addtsunami != nil {
		*m.addtsunami += i
	} else {
		m.addtsunami = &i
	}
}

// AddedTsunami returns the value that was added to the "tsunami" field in this mutation.
func (m *EarthquakeMutation) AddedTsunami() (r int32, exists bool) {
	v := m.addtsunami
	if v == nil {
		return
	}
	return *v, true
}

// ClearTsunami clears the value of the "tsunami" field.
func (m *EarthquakeMutation) ClearTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	m.clearedFields[earthquake.FieldTsunami] = struct{}{}
}

// TsunamiCleared returns if the "tsunami" field was cleared in this mutation.
func (m *EarthquakeMutation) TsunamiCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTsunami]
	return ok
}

// ResetTsunami resets all changes to the "tsunami" field.
func (m *EarthquakeMutation) ResetTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	delete(m.clearedFields, earthquake.FieldTsunami)
}

// SetSig sets the "sig" field.
func (m *EarthquakeMutation) SetSig(i int32) {
	m.sig = &i
	m.addsig = nil
}

// Sig returns the value of the "sig" field in the mutation.
func (m *EarthquakeMutation) Sig() (r int32, exists bool) {
	v := m.sig
	if v == nil {
		return
	}
	return *v, true
}

// OldSig returns the old "sig" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldSig(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSig: %w", err)
	}
	return oldValue.Sig, nil
}

// AddSig adds i to the "sig" field.
func (m *EarthquakeMutation) AddSig(i int32) {
	if m.addsig != nil {
		*m.addsig += i
	} else {
		m.addsig = &i
	}
}

// AddedSig returns the value that was added to the "sig" field in this mutation.
func (m *EarthquakeMutation) AddedSig() (r int32, exists bool) {
	v := m.addsig
	if v == nil {
		return
	}
	return *v, true
}

// ClearSig clears the value of the "sig" field.
func (m *EarthquakeMutation) ClearSig() {
	m.sig = nil
	m.addsig = nil
	m.clearedFields[earthquake.FieldSig] = struct{}{}
}

// SigCleared returns if the "sig" field was cleared in this mutation.
func (m *EarthquakeMutation) SigCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldSig]
	return ok
}

// ResetSig resets all changes to the "sig" field.
func (m *EarthquakeMutation) ResetSig() {
	m.sig = nil
	m.addsig = nil
	delete(m.clearedFields, earthquake.FieldSig)
}

// SetNet sets the "net" field.
func (m *EarthquakeMutation) SetNet(s string) {
	m.net = &s
}

// Net returns the value of the "net" field in the mutation.
func (m *EarthquakeMutation) Net() (r string, exists bool) {
	v := m.net
	if v == nil {
		return
	}
	return *v, true
}

// OldNet returns the old "net" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNet: %w", err)
	}
	return oldValue.Net, nil
}

// ClearNet clears the value of the "net" field.
func (m *EarthquakeMutation) ClearNet() {
	m.net = nil
	m.clearedFields[earthquake.FieldNet] = struct{}{}
}

// NetCleared returns if the "net" field was cleared in this mutation.
func (m *EarthquakeMutation) NetCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNet]
	return ok
}

// ResetNet resets all changes to the "net" field.
func (m *EarthquakeMutation) ResetNet() {
	m.net = nil
	delete(m.clearedFields, earthquake.FieldNet)
}

// SetCode sets the "code" field.
func (m *EarthquakeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EarthquakeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *EarthquakeMutation) ClearCode() {
	m.code = nil
	m.clearedFields[earthquake.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *EarthquakeMutation) CodeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *EarthquakeMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, earthquake.FieldCode)
}

// SetNst sets the "nst" field.
func (m *EarthquakeMutation) SetNst(i int32) {
	m.nst = &i
	m.addnst = nil
}

// Nst returns the value of the "nst" field in the mutation.
func (m *EarthquakeMutation) Nst() (r int32, exists bool) {
	v := m.nst
	if v == nil {
		return
	}
	return *v, true
}

// OldNst returns the old "nst" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNst(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNst: %w", err)
	}
	return oldValue.Nst, nil
}

// AddNst adds i to the "nst" field.
func (m *EarthquakeMutation) AddNst(i int32) {
	if m.addnst != nil {
		*m.addnst += i
	} else {
		m.addnst = &i
	}
}

// AddedNst returns the value that was added to the "nst" field in this mutation.
func (m *EarthquakeMutation) AddedNst() (r int32, exists bool) {
	v := m.addnst
	if v == nil {
		return
	}
	return *v, true
}

// ClearNst clears the value of the "nst" field.
func (m *EarthquakeMutation) ClearNst() {
	m.nst = nil
	m.addnst = nil
	m.clearedFields[earthquake.FieldNst] = struct{}{}
}

// NstCleared returns if the "nst" field was cleared in this mutation.
func (m *EarthquakeMutation) NstCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNst]
	return ok
}

// ResetNst resets all changes to the "nst" field.
func (m *EarthquakeMutation) ResetNst() {
	m.nst = nil
	m.addnst = nil
	delete(m.clearedFields, earthquake.FieldNst)
}

// SetDmin sets the "dmin" field.
func (m *EarthquakeMutation) SetDmin(f float64) {
	m.dmin = &f
	m.adddmin = nil
}

// Dmin returns the value of the "dmin" field in the mutation.
func (m *EarthquakeMutation) Dmin() (r float64, exists bool) {
	v := m.dmin
	if v == nil {
		return
	}
	return *v, true
}

// OldDmin returns the old "dmin" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDmin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDmin: %w", err)
	}
	return oldValue.Dmin, nil
}

// AddDmin adds f to the "dmin" field.
func (m *EarthquakeMutation) AddDmin(f float64) {
	if m.adddmin != nil {
		*m.adddmin += f
	} else {
		m.adddmin = &f
	}
}

// AddedDmin returns the value that was added to the "dmin" field in this mutation.
func (m *EarthquakeMutation) AddedDmin() (r float64, exists bool) {
	v := m.adddmin
	if v == nil {
		return
	}
	return *v, true
}

// ClearDmin clears the value of the "dmin" field.
func (m *EarthquakeMutation) ClearDmin() {
	m.dmin = nil
	m.adddmin = nil
	m.clearedFields[earthquake.FieldDmin] = struct{}{}
}

// DminCleared returns if the "dmin" field was cleared in this mutation.
func (m *EarthquakeMutation) DminCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDmin]
	return ok
}

// ResetDmin resets all changes to the "dmin" field.
func (m *EarthquakeMutation) ResetDmin() {
	m.dmin = nil
	m.adddmin = nil
	delete(m.clearedFields, earthquake.FieldDmin)
}

// SetRms sets the "rms" field.
func (m *EarthquakeMutation) SetRms(f float64) {
	m.rms = &f
	m.addrms = nil
}

// Rms returns the value of the "rms" field in the mutation.
func (m *EarthquakeMutation) Rms() (r float64, exists bool) {
	v := m.rms
	if v == nil {
		return
	}
	return *v, true
}

// OldRms returns the old "rms" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldRms(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRms: %w", err)
	}
	return oldValue.Rms, nil
}

// AddRms adds f to the "rms" field.
func (m *EarthquakeMutation) AddRms(f float64) {
	if m.addrms != nil {
		*m.addrms += f
	} else {
		m.addrms = &f
	}
}

// AddedRms returns the value that was added to the "rms" field in this mutation.
func (m *EarthquakeMutation) AddedRms() (r float64, exists bool) {
	v := m.addrms
	if v == nil {
		return
	}
	return *v, true
}

// ClearRms clears the value of the "rms" field.
func (m *EarthquakeMutation) ClearRms() {
	m.rms = nil
	m.addrms = nil
	m.clearedFields[earthquake.FieldRms] = struct{}{}
}

// RmsCleared returns if the "rms" field was cleared in this mutation.
func (m *EarthquakeMutation) RmsCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldRms]
	return ok
}

// ResetRms resets all changes to the "rms" field.
func (m *EarthquakeMutation) ResetRms() {
	m.rms = nil
	m.addrms = nil
	delete(m.clearedFields, earthquake.FieldRms)
}

// SetGap sets the "gap" field.
func (m *EarthquakeMutation) SetGap(f float64) {
	m.gap = &f
	m.addgap = nil
}

// Gap returns the value of the "gap" field in the mutation.
func (m *EarthquakeMutation) Gap() (r float64, exists bool) {
	v := m.gap
	if v == nil {
		return
	}
	return *v, true
}

// OldGap returns the old "gap" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGap(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGap: %w", err)
	}
	return oldValue.Gap, nil
}

// AddGap adds f to the "gap" field.
func (m *EarthquakeMutation) AddGap(f float64) {
	if m.addgap != nil {
		*m.addgap += f
	} else {
		m.addgap = &f
	}
}

// AddedGap returns the value that was added to the "gap" field in this mutation.
func (m *EarthquakeMutation) AddedGap() (r float64, exists bool) {
	v := m.addgap
	if v == nil {
		return
	}
	return *v, true
}

// ClearGap clears the value of the "gap" field.
func (m *EarthquakeMutation) ClearGap() {
	m.gap = nil
	m.addgap = nil
	m.clearedFields[earthquake.FieldGap] = struct{}{}
}

// GapCleared returns if the "gap" field was cleared in this mutation.
func (m *EarthquakeMutation) GapCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldGap]
	return ok
}

// ResetGap resets all changes to the "gap" field.
func (m *EarthquakeMutation) ResetGap() {
	m.gap = nil
	m.addgap = nil
	delete(m.clearedFields, earthquake.FieldGap)
}

// SetMagType sets the "mag_type" field.
func (m *EarthquakeMutation) SetMagType(s string) {
	m.mag_type = &s
}

// MagType returns the value of the "mag_type" field in the mutation.
func (m *EarthquakeMutation) MagType() (r string, exists bool) {
	v := m.mag_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMagType returns the old "mag_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMagType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagType: %w", err)
	}
	return oldValue.MagType, nil
}

// ClearMagType clears the value of the "mag_type" field.
func (m *EarthquakeMutation) ClearMagType() {
	m.mag_type = nil
	m.clearedFields[earthquake.FieldMagType] = struct{}{}
}

// MagTypeCleared returns if the "mag_type" field was cleared in this mutation.
func (m *EarthquakeMutation) MagTypeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldMagType]
	return ok
}

// ResetMagType resets all changes to the "mag_type" field.
func (m *EarthquakeMutation) ResetMagType() {
	m.mag_type = nil
	delete(m.clearedFields, earthquake.FieldMagType)
}

// SetEqType sets the "eq_type" field.
func (m *EarthquakeMutation) SetEqType(s string) {
	m.eq_type = &s
}

// EqType returns the value of the "eq_type" field in the mutation.
func (m *EarthquakeMutation) EqType() (r string, exists bool) {
	v := m.eq_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEqType returns the old "eq_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldEqType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqType: %w", err)
	}
	return oldValue.EqType, nil
}

// ClearEqType clears the value of the "eq_type" field.
func (m *EarthquakeMutation) ClearEqType() {
	m.eq_type = nil
	m.clearedFields[earthquake.FieldEqType] = struct{}{}
}

// EqTypeCleared returns if the "eq_type" field was cleared in this mutation.
func (m *EarthquakeMutation) EqTypeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldEqType]
	return ok
}

// ResetEqType resets all changes to the "eq_type" field.
func (m *EarthquakeMutation) ResetEqType() {
	m.eq_type = nil
	delete(m.clearedFields, earthquake.FieldEqType)
}

// SetCreatedAt sets the "created_at" field.
func (m *EarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[earthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, earthquake.FieldDeletedAt)
}

// SetGeometryID sets the "geometry" edge to the Geometry entity by id.
func (m *EarthquakeMutation) SetGeometryID(id int) {
	m.geometry = &id
}

// ClearGeometry clears the "geometry" edge to the Geometry entity.
func (m *EarthquakeMutation) ClearGeometry() {
	m.clearedgeometry = true
	m.clearedFields[earthquake.FieldGeoID] = struct{}{}
}

// GeometryCleared reports if the "geometry" edge to the Geometry entity was cleared.
func (m *EarthquakeMutation) GeometryCleared() bool {
	return m.GeoIDCleared() || m.clearedgeometry
}

// GeometryID returns the "geometry" edge ID in the mutation.
func (m *EarthquakeMutation) GeometryID() (id int, exists bool) {
	if m.geometry != nil {
		return *m.geometry, true
	}
	return
}

// GeometryIDs returns the "geometry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GeometryID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) GeometryIDs() (ids []int) {
	if id := m.geometry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGeometry resets all changes to the "geometry" edge.
func (m *EarthquakeMutation) ResetGeometry() {
	m.geometry = nil
	m.clearedgeometry = false
}

// ClearReport clears the "report" edge to the Report entity.
func (m *EarthquakeMutation) ClearReport() {
	m.clearedreport = true
	m.clearedFields[earthquake.FieldReportID] = struct{}{}
}

// ReportCleared reports if the "report" edge to the Report entity was cleared.
func (m *EarthquakeMutation) ReportCleared() bool {
	return m.ReportIDCleared() || m.clearedreport
}

// ReportIDs returns the "report" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) ReportIDs() (ids []int) {
	if id := m.report; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReport resets all changes to the "report" edge.
func (m *EarthquakeMutation) ResetReport() {
	m.report = nil
	m.clearedreport = false
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by ids.
func (m *EarthquakeMutation) AddFtypeEarthquakeIDs(ids ...int) {
	if m.ftype_earthquakes == nil {
		m.ftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.ftype_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearFtypeEarthquakes clears the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *EarthquakeMutation) ClearFtypeEarthquakes() {
	m.clearedftype_earthquakes = true
}

// FtypeEarthquakesCleared reports if the "ftype_earthquakes" edge to the FtypeEarthquake entity was cleared.
func (m *EarthquakeMutation) FtypeEarthquakesCleared() bool {
	return m.clearedftype_earthquakes
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (m *EarthquakeMutation) RemoveFtypeEarthquakeIDs(ids ...int) {
	if m.removedftype_earthquakes == nil {
		m.removedftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ftype_earthquakes, ids[i])
		m.removedftype_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedFtypeEarthquakes returns the removed IDs of the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *EarthquakeMutation) RemovedFtypeEarthquakesIDs() (ids []int) {
	for id := range m.removedftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// FtypeEarthquakesIDs returns the "ftype_earthquakes" edge IDs in the mutation.
func (m *EarthquakeMutation) FtypeEarthquakesIDs() (ids []int) {
	for id := range m.ftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetFtypeEarthquakes resets all changes to the "ftype_earthquakes" edge.
func (m *EarthquakeMutation) ResetFtypeEarthquakes() {
	m.ftype_earthquakes = nil
	m.clearedftype_earthquakes = false
	m.removedftype_earthquakes = nil
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by ids.
func (m *EarthquakeMutation) AddSourceEarthquakeIDs(ids ...int) {
	if m.source_earthquakes == nil {
		m.source_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.source_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearSourceEarthquakes clears the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *EarthquakeMutation) ClearSourceEarthquakes() {
	m.clearedsource_earthquakes = true
}

// SourceEarthquakesCleared reports if the "source_earthquakes" edge to the SourceEarthquake entity was cleared.
func (m *EarthquakeMutation) SourceEarthquakesCleared() bool {
	return m.clearedsource_earthquakes
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (m *EarthquakeMutation) RemoveSourceEarthquakeIDs(ids ...int) {
	if m.removedsource_earthquakes == nil {
		m.removedsource_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.source_earthquakes, ids[i])
		m.removedsource_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedSourceEarthquakes returns the removed IDs of the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *EarthquakeMutation) RemovedSourceEarthquakesIDs() (ids []int) {
	for id := range m.removedsource_earthquakes {
		ids = append(ids, id)
	}
	return
}

// SourceEarthquakesIDs returns the "source_earthquakes" edge IDs in the mutation.
func (m *EarthquakeMutation) SourceEarthquakesIDs() (ids []int) {
	for id := range m.source_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetSourceEarthquakes resets all changes to the "source_earthquakes" edge.
func (m *EarthquakeMutation) ResetSourceEarthquakes() {
	m.source_earthquakes = nil
	m.clearedsource_earthquakes = false
	m.removedsource_earthquakes = nil
}

// Where appends a list predicates to the EarthquakeMutation builder.
func (m *EarthquakeMutation) Where(ps ...predicate.Earthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Earthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Earthquake).
func (m *EarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.geometry != nil {
		fields = append(fields, earthquake.FieldGeoID)
	}
	if m.report != nil {
		fields = append(fields, earthquake.FieldReportID)
	}
	if m.mag != nil {
		fields = append(fields, earthquake.FieldMag)
	}
	if m.time != nil {
		fields = append(fields, earthquake.FieldTime)
	}
	if m.updated_time != nil {
		fields = append(fields, earthquake.FieldUpdatedTime)
	}
	if m.tz != nil {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.url != nil {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.detail != nil {
		fields = append(fields, earthquake.FieldDetail)
	}
	if m.status != nil {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.tsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.sig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.net != nil {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.code != nil {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.nst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.dmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.rms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.gap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.mag_type != nil {
		fields = append(fields, earthquake.FieldMagType)
	}
	if m.eq_type != nil {
		fields = append(fields, earthquake.FieldEqType)
	}
	if m.created_at != nil {
		fields = append(fields, earthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, earthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldGeoID:
		return m.GeoID()
	case earthquake.FieldReportID:
		return m.ReportID()
	case earthquake.FieldMag:
		return m.Mag()
	case earthquake.FieldTime:
		return m.Time()
	case earthquake.FieldUpdatedTime:
		return m.UpdatedTime()
	case earthquake.FieldTz:
		return m.Tz()
	case earthquake.FieldURL:
		return m.URL()
	case earthquake.FieldDetail:
		return m.Detail()
	case earthquake.FieldStatus:
		return m.Status()
	case earthquake.FieldTsunami:
		return m.Tsunami()
	case earthquake.FieldSig:
		return m.Sig()
	case earthquake.FieldNet:
		return m.Net()
	case earthquake.FieldCode:
		return m.Code()
	case earthquake.FieldNst:
		return m.Nst()
	case earthquake.FieldDmin:
		return m.Dmin()
	case earthquake.FieldRms:
		return m.Rms()
	case earthquake.FieldGap:
		return m.Gap()
	case earthquake.FieldMagType:
		return m.MagType()
	case earthquake.FieldEqType:
		return m.EqType()
	case earthquake.FieldCreatedAt:
		return m.CreatedAt()
	case earthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case earthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earthquake.FieldGeoID:
		return m.OldGeoID(ctx)
	case earthquake.FieldReportID:
		return m.OldReportID(ctx)
	case earthquake.FieldMag:
		return m.OldMag(ctx)
	case earthquake.FieldTime:
		return m.OldTime(ctx)
	case earthquake.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case earthquake.FieldTz:
		return m.OldTz(ctx)
	case earthquake.FieldURL:
		return m.OldURL(ctx)
	case earthquake.FieldDetail:
		return m.OldDetail(ctx)
	case earthquake.FieldStatus:
		return m.OldStatus(ctx)
	case earthquake.FieldTsunami:
		return m.OldTsunami(ctx)
	case earthquake.FieldSig:
		return m.OldSig(ctx)
	case earthquake.FieldNet:
		return m.OldNet(ctx)
	case earthquake.FieldCode:
		return m.OldCode(ctx)
	case earthquake.FieldNst:
		return m.OldNst(ctx)
	case earthquake.FieldDmin:
		return m.OldDmin(ctx)
	case earthquake.FieldRms:
		return m.OldRms(ctx)
	case earthquake.FieldGap:
		return m.OldGap(ctx)
	case earthquake.FieldMagType:
		return m.OldMagType(ctx)
	case earthquake.FieldEqType:
		return m.OldEqType(ctx)
	case earthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case earthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Earthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoID(v)
		return nil
	case earthquake.FieldReportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportID(v)
		return nil
	case earthquake.FieldMag:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMag(v)
		return nil
	case earthquake.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case earthquake.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case earthquake.FieldTz:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTz(v)
		return nil
	case earthquake.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case earthquake.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case earthquake.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSig(v)
		return nil
	case earthquake.FieldNet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNet(v)
		return nil
	case earthquake.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGap(v)
		return nil
	case earthquake.FieldMagType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagType(v)
		return nil
	case earthquake.FieldEqType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqType(v)
		return nil
	case earthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case earthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarthquakeMutation) AddedFields() []string {
	var fields []string
	if m.addmag != nil {
		fields = append(fields, earthquake.FieldMag)
	}
	if m.addtz != nil {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.addtsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.addsig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.addnst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.adddmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.addrms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.addgap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldMag:
		return m.AddedMag()
	case earthquake.FieldTz:
		return m.AddedTz()
	case earthquake.FieldTsunami:
		return m.AddedTsunami()
	case earthquake.FieldSig:
		return m.AddedSig()
	case earthquake.FieldNst:
		return m.AddedNst()
	case earthquake.FieldDmin:
		return m.AddedDmin()
	case earthquake.FieldRms:
		return m.AddedRms()
	case earthquake.FieldGap:
		return m.AddedGap()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldMag:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMag(v)
		return nil
	case earthquake.FieldTz:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTz(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSig(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGap(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earthquake.FieldGeoID) {
		fields = append(fields, earthquake.FieldGeoID)
	}
	if m.FieldCleared(earthquake.FieldReportID) {
		fields = append(fields, earthquake.FieldReportID)
	}
	if m.FieldCleared(earthquake.FieldUpdatedTime) {
		fields = append(fields, earthquake.FieldUpdatedTime)
	}
	if m.FieldCleared(earthquake.FieldTz) {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.FieldCleared(earthquake.FieldURL) {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.FieldCleared(earthquake.FieldDetail) {
		fields = append(fields, earthquake.FieldDetail)
	}
	if m.FieldCleared(earthquake.FieldStatus) {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.FieldCleared(earthquake.FieldTsunami) {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.FieldCleared(earthquake.FieldSig) {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.FieldCleared(earthquake.FieldNet) {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.FieldCleared(earthquake.FieldCode) {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.FieldCleared(earthquake.FieldNst) {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.FieldCleared(earthquake.FieldDmin) {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.FieldCleared(earthquake.FieldRms) {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.FieldCleared(earthquake.FieldGap) {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.FieldCleared(earthquake.FieldMagType) {
		fields = append(fields, earthquake.FieldMagType)
	}
	if m.FieldCleared(earthquake.FieldEqType) {
		fields = append(fields, earthquake.FieldEqType)
	}
	if m.FieldCleared(earthquake.FieldDeletedAt) {
		fields = append(fields, earthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarthquakeMutation) ClearField(name string) error {
	switch name {
	case earthquake.FieldGeoID:
		m.ClearGeoID()
		return nil
	case earthquake.FieldReportID:
		m.ClearReportID()
		return nil
	case earthquake.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	case earthquake.FieldTz:
		m.ClearTz()
		return nil
	case earthquake.FieldURL:
		m.ClearURL()
		return nil
	case earthquake.FieldDetail:
		m.ClearDetail()
		return nil
	case earthquake.FieldStatus:
		m.ClearStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ClearTsunami()
		return nil
	case earthquake.FieldSig:
		m.ClearSig()
		return nil
	case earthquake.FieldNet:
		m.ClearNet()
		return nil
	case earthquake.FieldCode:
		m.ClearCode()
		return nil
	case earthquake.FieldNst:
		m.ClearNst()
		return nil
	case earthquake.FieldDmin:
		m.ClearDmin()
		return nil
	case earthquake.FieldRms:
		m.ClearRms()
		return nil
	case earthquake.FieldGap:
		m.ClearGap()
		return nil
	case earthquake.FieldMagType:
		m.ClearMagType()
		return nil
	case earthquake.FieldEqType:
		m.ClearEqType()
		return nil
	case earthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarthquakeMutation) ResetField(name string) error {
	switch name {
	case earthquake.FieldGeoID:
		m.ResetGeoID()
		return nil
	case earthquake.FieldReportID:
		m.ResetReportID()
		return nil
	case earthquake.FieldMag:
		m.ResetMag()
		return nil
	case earthquake.FieldTime:
		m.ResetTime()
		return nil
	case earthquake.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case earthquake.FieldTz:
		m.ResetTz()
		return nil
	case earthquake.FieldURL:
		m.ResetURL()
		return nil
	case earthquake.FieldDetail:
		m.ResetDetail()
		return nil
	case earthquake.FieldStatus:
		m.ResetStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ResetTsunami()
		return nil
	case earthquake.FieldSig:
		m.ResetSig()
		return nil
	case earthquake.FieldNet:
		m.ResetNet()
		return nil
	case earthquake.FieldCode:
		m.ResetCode()
		return nil
	case earthquake.FieldNst:
		m.ResetNst()
		return nil
	case earthquake.FieldDmin:
		m.ResetDmin()
		return nil
	case earthquake.FieldRms:
		m.ResetRms()
		return nil
	case earthquake.FieldGap:
		m.ResetGap()
		return nil
	case earthquake.FieldMagType:
		m.ResetMagType()
		return nil
	case earthquake.FieldEqType:
		m.ResetEqType()
		return nil
	case earthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case earthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.geometry != nil {
		edges = append(edges, earthquake.EdgeGeometry)
	}
	if m.report != nil {
		edges = append(edges, earthquake.EdgeReport)
	}
	if m.ftype_earthquakes != nil {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.source_earthquakes != nil {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeGeometry:
		if id := m.geometry; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeReport:
		if id := m.report; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.ftype_earthquakes))
		for id := range m.ftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.source_earthquakes))
		for id := range m.source_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedftype_earthquakes != nil {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.removedsource_earthquakes != nil {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarthquakeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedftype_earthquakes))
		for id := range m.removedftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedsource_earthquakes))
		for id := range m.removedsource_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgeometry {
		edges = append(edges, earthquake.EdgeGeometry)
	}
	if m.clearedreport {
		edges = append(edges, earthquake.EdgeReport)
	}
	if m.clearedftype_earthquakes {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.clearedsource_earthquakes {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case earthquake.EdgeGeometry:
		return m.clearedgeometry
	case earthquake.EdgeReport:
		return m.clearedreport
	case earthquake.EdgeFtypeEarthquakes:
		return m.clearedftype_earthquakes
	case earthquake.EdgeSourceEarthquakes:
		return m.clearedsource_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case earthquake.EdgeGeometry:
		m.ClearGeometry()
		return nil
	case earthquake.EdgeReport:
		m.ClearReport()
		return nil
	}
	return fmt.Errorf("unknown Earthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case earthquake.EdgeGeometry:
		m.ResetGeometry()
		return nil
	case earthquake.EdgeReport:
		m.ResetReport()
		return nil
	case earthquake.EdgeFtypeEarthquakes:
		m.ResetFtypeEarthquakes()
		return nil
	case earthquake.EdgeSourceEarthquakes:
		m.ResetSourceEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Earthquake edge %s", name)
}

// FeatureTypeMutation represents an operation that mutates the FeatureType nodes in the graph.
type FeatureTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	feat_type                *string
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	ftype_earthquakes        map[int]struct{}
	removedftype_earthquakes map[int]struct{}
	clearedftype_earthquakes bool
	done                     bool
	oldValue                 func(context.Context) (*FeatureType, error)
	predicates               []predicate.FeatureType
}

var _ ent.Mutation = (*FeatureTypeMutation)(nil)

// featuretypeOption allows management of the mutation configuration using functional options.
type featuretypeOption func(*FeatureTypeMutation)

// newFeatureTypeMutation creates new mutation for the FeatureType entity.
func newFeatureTypeMutation(c config, op Op, opts ...featuretypeOption) *FeatureTypeMutation {
	m := &FeatureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureTypeID sets the ID field of the mutation.
func withFeatureTypeID(id int) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureType
		)
		m.oldValue = func(ctx context.Context) (*FeatureType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureType sets the old FeatureType of the mutation.
func withFeatureType(node *FeatureType) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		m.oldValue = func(context.Context) (*FeatureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureType entities.
func (m *FeatureTypeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatType sets the "feat_type" field.
func (m *FeatureTypeMutation) SetFeatType(s string) {
	m.feat_type = &s
}

// FeatType returns the value of the "feat_type" field in the mutation.
func (m *FeatureTypeMutation) FeatType() (r string, exists bool) {
	v := m.feat_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatType returns the old "feat_type" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldFeatType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatType: %w", err)
	}
	return oldValue.FeatType, nil
}

// ClearFeatType clears the value of the "feat_type" field.
func (m *FeatureTypeMutation) ClearFeatType() {
	m.feat_type = nil
	m.clearedFields[featuretype.FieldFeatType] = struct{}{}
}

// FeatTypeCleared returns if the "feat_type" field was cleared in this mutation.
func (m *FeatureTypeMutation) FeatTypeCleared() bool {
	_, ok := m.clearedFields[featuretype.FieldFeatType]
	return ok
}

// ResetFeatType resets all changes to the "feat_type" field.
func (m *FeatureTypeMutation) ResetFeatType() {
	m.feat_type = nil
	delete(m.clearedFields, featuretype.FieldFeatType)
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featuretype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featuretype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featuretype.FieldDeletedAt)
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by ids.
func (m *FeatureTypeMutation) AddFtypeEarthquakeIDs(ids ...int) {
	if m.ftype_earthquakes == nil {
		m.ftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.ftype_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearFtypeEarthquakes clears the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *FeatureTypeMutation) ClearFtypeEarthquakes() {
	m.clearedftype_earthquakes = true
}

// FtypeEarthquakesCleared reports if the "ftype_earthquakes" edge to the FtypeEarthquake entity was cleared.
func (m *FeatureTypeMutation) FtypeEarthquakesCleared() bool {
	return m.clearedftype_earthquakes
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (m *FeatureTypeMutation) RemoveFtypeEarthquakeIDs(ids ...int) {
	if m.removedftype_earthquakes == nil {
		m.removedftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ftype_earthquakes, ids[i])
		m.removedftype_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedFtypeEarthquakes returns the removed IDs of the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *FeatureTypeMutation) RemovedFtypeEarthquakesIDs() (ids []int) {
	for id := range m.removedftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// FtypeEarthquakesIDs returns the "ftype_earthquakes" edge IDs in the mutation.
func (m *FeatureTypeMutation) FtypeEarthquakesIDs() (ids []int) {
	for id := range m.ftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetFtypeEarthquakes resets all changes to the "ftype_earthquakes" edge.
func (m *FeatureTypeMutation) ResetFtypeEarthquakes() {
	m.ftype_earthquakes = nil
	m.clearedftype_earthquakes = false
	m.removedftype_earthquakes = nil
}

// Where appends a list predicates to the FeatureTypeMutation builder.
func (m *FeatureTypeMutation) Where(ps ...predicate.FeatureType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureType).
func (m *FeatureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.feat_type != nil {
		fields = append(fields, featuretype.FieldFeatType)
	}
	if m.created_at != nil {
		fields = append(fields, featuretype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featuretype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featuretype.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuretype.FieldFeatType:
		return m.FeatType()
	case featuretype.FieldCreatedAt:
		return m.CreatedAt()
	case featuretype.FieldUpdatedAt:
		return m.UpdatedAt()
	case featuretype.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuretype.FieldFeatType:
		return m.OldFeatType(ctx)
	case featuretype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featuretype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featuretype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuretype.FieldFeatType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatType(v)
		return nil
	case featuretype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featuretype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featuretype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuretype.FieldFeatType) {
		fields = append(fields, featuretype.FieldFeatType)
	}
	if m.FieldCleared(featuretype.FieldDeletedAt) {
		fields = append(fields, featuretype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ClearField(name string) error {
	switch name {
	case featuretype.FieldFeatType:
		m.ClearFeatType()
		return nil
	case featuretype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ResetField(name string) error {
	switch name {
	case featuretype.FieldFeatType:
		m.ResetFeatType()
		return nil
	case featuretype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featuretype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featuretype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ftype_earthquakes != nil {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.ftype_earthquakes))
		for id := range m.ftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedftype_earthquakes != nil {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedftype_earthquakes))
		for id := range m.removedftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedftype_earthquakes {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		return m.clearedftype_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureTypeMutation) ResetEdge(name string) error {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		m.ResetFtypeEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown FeatureType edge %s", name)
}

// FtypeEarthquakeMutation represents an operation that mutates the FtypeEarthquake nodes in the graph.
type FtypeEarthquakeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	earthquake          *int
	clearedearthquake   bool
	feature_type        *int
	clearedfeature_type bool
	done                bool
	oldValue            func(context.Context) (*FtypeEarthquake, error)
	predicates          []predicate.FtypeEarthquake
}

var _ ent.Mutation = (*FtypeEarthquakeMutation)(nil)

// ftypeearthquakeOption allows management of the mutation configuration using functional options.
type ftypeearthquakeOption func(*FtypeEarthquakeMutation)

// newFtypeEarthquakeMutation creates new mutation for the FtypeEarthquake entity.
func newFtypeEarthquakeMutation(c config, op Op, opts ...ftypeearthquakeOption) *FtypeEarthquakeMutation {
	m := &FtypeEarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeFtypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFtypeEarthquakeID sets the ID field of the mutation.
func withFtypeEarthquakeID(id int) ftypeearthquakeOption {
	return func(m *FtypeEarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *FtypeEarthquake
		)
		m.oldValue = func(ctx context.Context) (*FtypeEarthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FtypeEarthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFtypeEarthquake sets the old FtypeEarthquake of the mutation.
func withFtypeEarthquake(node *FtypeEarthquake) ftypeearthquakeOption {
	return func(m *FtypeEarthquakeMutation) {
		m.oldValue = func(context.Context) (*FtypeEarthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FtypeEarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FtypeEarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FtypeEarthquake entities.
func (m *FtypeEarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FtypeEarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FtypeEarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FtypeEarthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFtID sets the "ft_id" field.
func (m *FtypeEarthquakeMutation) SetFtID(i int) {
	m.feature_type = &i
}

// FtID returns the value of the "ft_id" field in the mutation.
func (m *FtypeEarthquakeMutation) FtID() (r int, exists bool) {
	v := m.feature_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFtID returns the old "ft_id" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldFtID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFtID: %w", err)
	}
	return oldValue.FtID, nil
}

// ClearFtID clears the value of the "ft_id" field.
func (m *FtypeEarthquakeMutation) ClearFtID() {
	m.feature_type = nil
	m.clearedFields[ftypeearthquake.FieldFtID] = struct{}{}
}

// FtIDCleared returns if the "ft_id" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) FtIDCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldFtID]
	return ok
}

// ResetFtID resets all changes to the "ft_id" field.
func (m *FtypeEarthquakeMutation) ResetFtID() {
	m.feature_type = nil
	delete(m.clearedFields, ftypeearthquake.FieldFtID)
}

// SetEqID sets the "eq_id" field.
func (m *FtypeEarthquakeMutation) SetEqID(i int) {
	m.earthquake = &i
}

// EqID returns the value of the "eq_id" field in the mutation.
func (m *FtypeEarthquakeMutation) EqID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEqID returns the old "eq_id" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldEqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqID: %w", err)
	}
	return oldValue.EqID, nil
}

// ClearEqID clears the value of the "eq_id" field.
func (m *FtypeEarthquakeMutation) ClearEqID() {
	m.earthquake = nil
	m.clearedFields[ftypeearthquake.FieldEqID] = struct{}{}
}

// EqIDCleared returns if the "eq_id" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) EqIDCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldEqID]
	return ok
}

// ResetEqID resets all changes to the "eq_id" field.
func (m *FtypeEarthquakeMutation) ResetEqID() {
	m.earthquake = nil
	delete(m.clearedFields, ftypeearthquake.FieldEqID)
}

// SetCreatedAt sets the "created_at" field.
func (m *FtypeEarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FtypeEarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FtypeEarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FtypeEarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FtypeEarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FtypeEarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FtypeEarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FtypeEarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FtypeEarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ftypeearthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FtypeEarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ftypeearthquake.FieldDeletedAt)
}

// SetEarthquakeID sets the "earthquake" edge to the Earthquake entity by id.
func (m *FtypeEarthquakeMutation) SetEarthquakeID(id int) {
	m.earthquake = &id
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *FtypeEarthquakeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[ftypeearthquake.FieldEqID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *FtypeEarthquakeMutation) EarthquakeCleared() bool {
	return m.EqIDCleared() || m.clearedearthquake
}

// EarthquakeID returns the "earthquake" edge ID in the mutation.
func (m *FtypeEarthquakeMutation) EarthquakeID() (id int, exists bool) {
	if m.earthquake != nil {
		return *m.earthquake, true
	}
	return
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *FtypeEarthquakeMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *FtypeEarthquakeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// SetFeatureTypeID sets the "feature_type" edge to the FeatureType entity by id.
func (m *FtypeEarthquakeMutation) SetFeatureTypeID(id int) {
	m.feature_type = &id
}

// ClearFeatureType clears the "feature_type" edge to the FeatureType entity.
func (m *FtypeEarthquakeMutation) ClearFeatureType() {
	m.clearedfeature_type = true
	m.clearedFields[ftypeearthquake.FieldFtID] = struct{}{}
}

// FeatureTypeCleared reports if the "feature_type" edge to the FeatureType entity was cleared.
func (m *FtypeEarthquakeMutation) FeatureTypeCleared() bool {
	return m.FtIDCleared() || m.clearedfeature_type
}

// FeatureTypeID returns the "feature_type" edge ID in the mutation.
func (m *FtypeEarthquakeMutation) FeatureTypeID() (id int, exists bool) {
	if m.feature_type != nil {
		return *m.feature_type, true
	}
	return
}

// FeatureTypeIDs returns the "feature_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureTypeID instead. It exists only for internal usage by the builders.
func (m *FtypeEarthquakeMutation) FeatureTypeIDs() (ids []int) {
	if id := m.feature_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatureType resets all changes to the "feature_type" edge.
func (m *FtypeEarthquakeMutation) ResetFeatureType() {
	m.feature_type = nil
	m.clearedfeature_type = false
}

// Where appends a list predicates to the FtypeEarthquakeMutation builder.
func (m *FtypeEarthquakeMutation) Where(ps ...predicate.FtypeEarthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FtypeEarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FtypeEarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FtypeEarthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FtypeEarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FtypeEarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FtypeEarthquake).
func (m *FtypeEarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FtypeEarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.feature_type != nil {
		fields = append(fields, ftypeearthquake.FieldFtID)
	}
	if m.earthquake != nil {
		fields = append(fields, ftypeearthquake.FieldEqID)
	}
	if m.created_at != nil {
		fields = append(fields, ftypeearthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ftypeearthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ftypeearthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FtypeEarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ftypeearthquake.FieldFtID:
		return m.FtID()
	case ftypeearthquake.FieldEqID:
		return m.EqID()
	case ftypeearthquake.FieldCreatedAt:
		return m.CreatedAt()
	case ftypeearthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case ftypeearthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FtypeEarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ftypeearthquake.FieldFtID:
		return m.OldFtID(ctx)
	case ftypeearthquake.FieldEqID:
		return m.OldEqID(ctx)
	case ftypeearthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ftypeearthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ftypeearthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FtypeEarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFtID(v)
		return nil
	case ftypeearthquake.FieldEqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqID(v)
		return nil
	case ftypeearthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ftypeearthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ftypeearthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FtypeEarthquakeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FtypeEarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FtypeEarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FtypeEarthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FtypeEarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ftypeearthquake.FieldFtID) {
		fields = append(fields, ftypeearthquake.FieldFtID)
	}
	if m.FieldCleared(ftypeearthquake.FieldEqID) {
		fields = append(fields, ftypeearthquake.FieldEqID)
	}
	if m.FieldCleared(ftypeearthquake.FieldDeletedAt) {
		fields = append(fields, ftypeearthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FtypeEarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FtypeEarthquakeMutation) ClearField(name string) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		m.ClearFtID()
		return nil
	case ftypeearthquake.FieldEqID:
		m.ClearEqID()
		return nil
	case ftypeearthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FtypeEarthquakeMutation) ResetField(name string) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		m.ResetFtID()
		return nil
	case ftypeearthquake.FieldEqID:
		m.ResetEqID()
		return nil
	case ftypeearthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ftypeearthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ftypeearthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FtypeEarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquake != nil {
		edges = append(edges, ftypeearthquake.EdgeEarthquake)
	}
	if m.feature_type != nil {
		edges = append(edges, ftypeearthquake.EdgeFeatureType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FtypeEarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	case ftypeearthquake.EdgeFeatureType:
		if id := m.feature_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FtypeEarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FtypeEarthquakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FtypeEarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquake {
		edges = append(edges, ftypeearthquake.EdgeEarthquake)
	}
	if m.clearedfeature_type {
		edges = append(edges, ftypeearthquake.EdgeFeatureType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FtypeEarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		return m.clearedearthquake
	case ftypeearthquake.EdgeFeatureType:
		return m.clearedfeature_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FtypeEarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	case ftypeearthquake.EdgeFeatureType:
		m.ClearFeatureType()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FtypeEarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	case ftypeearthquake.EdgeFeatureType:
		m.ResetFeatureType()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake edge %s", name)
}

// GeometryMutation represents an operation that mutates the Geometry nodes in the graph.
type GeometryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	longitude          *float64
	addlongitude       *float64
	latitude           *float64
	addlatitude        *float64
	depth              *float64
	adddepth           *float64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	location           *int
	clearedlocation    bool
	done               bool
	oldValue           func(context.Context) (*Geometry, error)
	predicates         []predicate.Geometry
}

var _ ent.Mutation = (*GeometryMutation)(nil)

// geometryOption allows management of the mutation configuration using functional options.
type geometryOption func(*GeometryMutation)

// newGeometryMutation creates new mutation for the Geometry entity.
func newGeometryMutation(c config, op Op, opts ...geometryOption) *GeometryMutation {
	m := &GeometryMutation{
		config:        c,
		op:            op,
		typ:           TypeGeometry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeometryID sets the ID field of the mutation.
func withGeometryID(id int) geometryOption {
	return func(m *GeometryMutation) {
		var (
			err   error
			once  sync.Once
			value *Geometry
		)
		m.oldValue = func(ctx context.Context) (*Geometry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Geometry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeometry sets the old Geometry of the mutation.
func withGeometry(node *Geometry) geometryOption {
	return func(m *GeometryMutation) {
		m.oldValue = func(context.Context) (*Geometry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeometryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeometryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Geometry entities.
func (m *GeometryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeometryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeometryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Geometry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocationID sets the "location_id" field.
func (m *GeometryMutation) SetLocationID(i int) {
	m.location = &i
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *GeometryMutation) LocationID() (r int, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *GeometryMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[geometry.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *GeometryMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[geometry.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *GeometryMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, geometry.FieldLocationID)
}

// SetLongitude sets the "longitude" field.
func (m *GeometryMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *GeometryMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *GeometryMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *GeometryMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *GeometryMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *GeometryMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *GeometryMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *GeometryMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *GeometryMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *GeometryMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetDepth sets the "depth" field.
func (m *GeometryMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *GeometryMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *GeometryMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *GeometryMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *GeometryMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GeometryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeometryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeometryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeometryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeometryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeometryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GeometryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GeometryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GeometryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[geometry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GeometryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[geometry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GeometryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, geometry.FieldDeletedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *GeometryMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *GeometryMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *GeometryMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *GeometryMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *GeometryMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *GeometryMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *GeometryMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *GeometryMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[geometry.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *GeometryMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *GeometryMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *GeometryMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the GeometryMutation builder.
func (m *GeometryMutation) Where(ps ...predicate.Geometry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeometryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeometryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Geometry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeometryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeometryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Geometry).
func (m *GeometryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeometryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.location != nil {
		fields = append(fields, geometry.FieldLocationID)
	}
	if m.longitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.depth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	if m.created_at != nil {
		fields = append(fields, geometry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, geometry.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, geometry.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeometryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldLocationID:
		return m.LocationID()
	case geometry.FieldLongitude:
		return m.Longitude()
	case geometry.FieldLatitude:
		return m.Latitude()
	case geometry.FieldDepth:
		return m.Depth()
	case geometry.FieldCreatedAt:
		return m.CreatedAt()
	case geometry.FieldUpdatedAt:
		return m.UpdatedAt()
	case geometry.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeometryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case geometry.FieldLocationID:
		return m.OldLocationID(ctx)
	case geometry.FieldLongitude:
		return m.OldLongitude(ctx)
	case geometry.FieldLatitude:
		return m.OldLatitude(ctx)
	case geometry.FieldDepth:
		return m.OldDepth(ctx)
	case geometry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case geometry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case geometry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Geometry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case geometry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case geometry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case geometry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeometryMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.adddepth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeometryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldLongitude:
		return m.AddedLongitude()
	case geometry.FieldLatitude:
		return m.AddedLatitude()
	case geometry.FieldDepth:
		return m.AddedDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeometryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(geometry.FieldLocationID) {
		fields = append(fields, geometry.FieldLocationID)
	}
	if m.FieldCleared(geometry.FieldDeletedAt) {
		fields = append(fields, geometry.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeometryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeometryMutation) ClearField(name string) error {
	switch name {
	case geometry.FieldLocationID:
		m.ClearLocationID()
		return nil
	case geometry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Geometry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeometryMutation) ResetField(name string) error {
	switch name {
	case geometry.FieldLocationID:
		m.ResetLocationID()
		return nil
	case geometry.FieldLongitude:
		m.ResetLongitude()
		return nil
	case geometry.FieldLatitude:
		m.ResetLatitude()
		return nil
	case geometry.FieldDepth:
		m.ResetDepth()
		return nil
	case geometry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case geometry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case geometry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeometryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquakes != nil {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	if m.location != nil {
		edges = append(edges, geometry.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeometryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case geometry.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	case geometry.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeometryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearthquakes != nil {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeometryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case geometry.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeometryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquakes {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	if m.clearedlocation {
		edges = append(edges, geometry.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeometryMutation) EdgeCleared(name string) bool {
	switch name {
	case geometry.EdgeEarthquakes:
		return m.clearedearthquakes
	case geometry.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeometryMutation) ClearEdge(name string) error {
	switch name {
	case geometry.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Geometry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeometryMutation) ResetEdge(name string) error {
	switch name {
	case geometry.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	case geometry.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Geometry edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	place             *string
	address           *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	geometries        map[int]struct{}
	removedgeometries map[int]struct{}
	clearedgeometries bool
	done              bool
	oldValue          func(context.Context) (*Location, error)
	predicates        []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlace sets the "place" field.
func (m *LocationMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *LocationMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ClearPlace clears the value of the "place" field.
func (m *LocationMutation) ClearPlace() {
	m.place = nil
	m.clearedFields[location.FieldPlace] = struct{}{}
}

// PlaceCleared returns if the "place" field was cleared in this mutation.
func (m *LocationMutation) PlaceCleared() bool {
	_, ok := m.clearedFields[location.FieldPlace]
	return ok
}

// ResetPlace resets all changes to the "place" field.
func (m *LocationMutation) ResetPlace() {
	m.place = nil
	delete(m.clearedFields, location.FieldPlace)
}

// SetAddress sets the "address" field.
func (m *LocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[location.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[location.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, location.FieldAddress)
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[location.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[location.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, location.FieldDeletedAt)
}

// AddGeometryIDs adds the "geometries" edge to the Geometry entity by ids.
func (m *LocationMutation) AddGeometryIDs(ids ...int) {
	if m.geometries == nil {
		m.geometries = make(map[int]struct{})
	}
	for i := range ids {
		m.geometries[ids[i]] = struct{}{}
	}
}

// ClearGeometries clears the "geometries" edge to the Geometry entity.
func (m *LocationMutation) ClearGeometries() {
	m.clearedgeometries = true
}

// GeometriesCleared reports if the "geometries" edge to the Geometry entity was cleared.
func (m *LocationMutation) GeometriesCleared() bool {
	return m.clearedgeometries
}

// RemoveGeometryIDs removes the "geometries" edge to the Geometry entity by IDs.
func (m *LocationMutation) RemoveGeometryIDs(ids ...int) {
	if m.removedgeometries == nil {
		m.removedgeometries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.geometries, ids[i])
		m.removedgeometries[ids[i]] = struct{}{}
	}
}

// RemovedGeometries returns the removed IDs of the "geometries" edge to the Geometry entity.
func (m *LocationMutation) RemovedGeometriesIDs() (ids []int) {
	for id := range m.removedgeometries {
		ids = append(ids, id)
	}
	return
}

// GeometriesIDs returns the "geometries" edge IDs in the mutation.
func (m *LocationMutation) GeometriesIDs() (ids []int) {
	for id := range m.geometries {
		ids = append(ids, id)
	}
	return
}

// ResetGeometries resets all changes to the "geometries" edge.
func (m *LocationMutation) ResetGeometries() {
	m.geometries = nil
	m.clearedgeometries = false
	m.removedgeometries = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.place != nil {
		fields = append(fields, location.FieldPlace)
	}
	if m.address != nil {
		fields = append(fields, location.FieldAddress)
	}
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, location.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldPlace:
		return m.Place()
	case location.FieldAddress:
		return m.Address()
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldPlace:
		return m.OldPlace(ctx)
	case location.FieldAddress:
		return m.OldAddress(ctx)
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case location.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldPlace) {
		fields = append(fields, location.FieldPlace)
	}
	if m.FieldCleared(location.FieldAddress) {
		fields = append(fields, location.FieldAddress)
	}
	if m.FieldCleared(location.FieldDeletedAt) {
		fields = append(fields, location.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldPlace:
		m.ClearPlace()
		return nil
	case location.FieldAddress:
		m.ClearAddress()
		return nil
	case location.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldPlace:
		m.ResetPlace()
		return nil
	case location.FieldAddress:
		m.ResetAddress()
		return nil
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.geometries != nil {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.geometries))
		for id := range m.geometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgeometries != nil {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.removedgeometries))
		for id := range m.removedgeometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgeometries {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeGeometries:
		return m.clearedgeometries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeGeometries:
		m.ResetGeometries()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// PasswordResetRequestMutation represents an operation that mutates the PasswordResetRequest nodes in the graph.
type PasswordResetRequestMutation struct {
	config
	op              Op
	typ             string
	id              *int
	token_value     *string
	expiration_time *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*PasswordResetRequest, error)
	predicates      []predicate.PasswordResetRequest
}

var _ ent.Mutation = (*PasswordResetRequestMutation)(nil)

// passwordresetrequestOption allows management of the mutation configuration using functional options.
type passwordresetrequestOption func(*PasswordResetRequestMutation)

// newPasswordResetRequestMutation creates new mutation for the PasswordResetRequest entity.
func newPasswordResetRequestMutation(c config, op Op, opts ...passwordresetrequestOption) *PasswordResetRequestMutation {
	m := &PasswordResetRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePasswordResetRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPasswordResetRequestID sets the ID field of the mutation.
func withPasswordResetRequestID(id int) passwordresetrequestOption {
	return func(m *PasswordResetRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PasswordResetRequest
		)
		m.oldValue = func(ctx context.Context) (*PasswordResetRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PasswordResetRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPasswordResetRequest sets the old PasswordResetRequest of the mutation.
func withPasswordResetRequest(node *PasswordResetRequest) passwordresetrequestOption {
	return func(m *PasswordResetRequestMutation) {
		m.oldValue = func(context.Context) (*PasswordResetRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PasswordResetRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PasswordResetRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PasswordResetRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PasswordResetRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PasswordResetRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PasswordResetRequestMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PasswordResetRequestMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PasswordResetRequest entity.
// If the PasswordResetRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetRequestMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PasswordResetRequestMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[passwordresetrequest.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PasswordResetRequestMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[passwordresetrequest.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PasswordResetRequestMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, passwordresetrequest.FieldUserID)
}

// SetTokenValue sets the "token_value" field.
func (m *PasswordResetRequestMutation) SetTokenValue(s string) {
	m.token_value = &s
}

// TokenValue returns the value of the "token_value" field in the mutation.
func (m *PasswordResetRequestMutation) TokenValue() (r string, exists bool) {
	v := m.token_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValue returns the old "token_value" field's value of the PasswordResetRequest entity.
// If the PasswordResetRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetRequestMutation) OldTokenValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValue: %w", err)
	}
	return oldValue.TokenValue, nil
}

// ResetTokenValue resets all changes to the "token_value" field.
func (m *PasswordResetRequestMutation) ResetTokenValue() {
	m.token_value = nil
}

// SetExpirationTime sets the "expiration_time" field.
func (m *PasswordResetRequestMutation) SetExpirationTime(t time.Time) {
	m.expiration_time = &t
}

// ExpirationTime returns the value of the "expiration_time" field in the mutation.
func (m *PasswordResetRequestMutation) ExpirationTime() (r time.Time, exists bool) {
	v := m.expiration_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationTime returns the old "expiration_time" field's value of the PasswordResetRequest entity.
// If the PasswordResetRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PasswordResetRequestMutation) OldExpirationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationTime: %w", err)
	}
	return oldValue.ExpirationTime, nil
}

// ResetExpirationTime resets all changes to the "expiration_time" field.
func (m *PasswordResetRequestMutation) ResetExpirationTime() {
	m.expiration_time = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PasswordResetRequestMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[passwordresetrequest.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PasswordResetRequestMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PasswordResetRequestMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PasswordResetRequestMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PasswordResetRequestMutation builder.
func (m *PasswordResetRequestMutation) Where(ps ...predicate.PasswordResetRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PasswordResetRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PasswordResetRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PasswordResetRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PasswordResetRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PasswordResetRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PasswordResetRequest).
func (m *PasswordResetRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PasswordResetRequestMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, passwordresetrequest.FieldUserID)
	}
	if m.token_value != nil {
		fields = append(fields, passwordresetrequest.FieldTokenValue)
	}
	if m.expiration_time != nil {
		fields = append(fields, passwordresetrequest.FieldExpirationTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PasswordResetRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passwordresetrequest.FieldUserID:
		return m.UserID()
	case passwordresetrequest.FieldTokenValue:
		return m.TokenValue()
	case passwordresetrequest.FieldExpirationTime:
		return m.ExpirationTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PasswordResetRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passwordresetrequest.FieldUserID:
		return m.OldUserID(ctx)
	case passwordresetrequest.FieldTokenValue:
		return m.OldTokenValue(ctx)
	case passwordresetrequest.FieldExpirationTime:
		return m.OldExpirationTime(ctx)
	}
	return nil, fmt.Errorf("unknown PasswordResetRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passwordresetrequest.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case passwordresetrequest.FieldTokenValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValue(v)
		return nil
	case passwordresetrequest.FieldExpirationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationTime(v)
		return nil
	}
	return fmt.Errorf("unknown PasswordResetRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PasswordResetRequestMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PasswordResetRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PasswordResetRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PasswordResetRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PasswordResetRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(passwordresetrequest.FieldUserID) {
		fields = append(fields, passwordresetrequest.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PasswordResetRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PasswordResetRequestMutation) ClearField(name string) error {
	switch name {
	case passwordresetrequest.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PasswordResetRequestMutation) ResetField(name string) error {
	switch name {
	case passwordresetrequest.FieldUserID:
		m.ResetUserID()
		return nil
	case passwordresetrequest.FieldTokenValue:
		m.ResetTokenValue()
		return nil
	case passwordresetrequest.FieldExpirationTime:
		m.ResetExpirationTime()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PasswordResetRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, passwordresetrequest.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PasswordResetRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passwordresetrequest.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PasswordResetRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PasswordResetRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PasswordResetRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, passwordresetrequest.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PasswordResetRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case passwordresetrequest.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PasswordResetRequestMutation) ClearEdge(name string) error {
	switch name {
	case passwordresetrequest.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PasswordResetRequestMutation) ResetEdge(name string) error {
	switch name {
	case passwordresetrequest.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PasswordResetRequest edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	felt               *int32
	addfelt            *int32
	cdi                *float64
	addcdi             *float64
	mmi                *float64
	addmmi             *float64
	alert              *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	done               bool
	oldValue           func(context.Context) (*Report, error)
	predicates         []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id int) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFelt sets the "felt" field.
func (m *ReportMutation) SetFelt(i int32) {
	m.felt = &i
	m.addfelt = nil
}

// Felt returns the value of the "felt" field in the mutation.
func (m *ReportMutation) Felt() (r int32, exists bool) {
	v := m.felt
	if v == nil {
		return
	}
	return *v, true
}

// OldFelt returns the old "felt" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldFelt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFelt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFelt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFelt: %w", err)
	}
	return oldValue.Felt, nil
}

// AddFelt adds i to the "felt" field.
func (m *ReportMutation) AddFelt(i int32) {
	if m.addfelt != nil {
		*m.addfelt += i
	} else {
		m.addfelt = &i
	}
}

// AddedFelt returns the value that was added to the "felt" field in this mutation.
func (m *ReportMutation) AddedFelt() (r int32, exists bool) {
	v := m.addfelt
	if v == nil {
		return
	}
	return *v, true
}

// ClearFelt clears the value of the "felt" field.
func (m *ReportMutation) ClearFelt() {
	m.felt = nil
	m.addfelt = nil
	m.clearedFields[report.FieldFelt] = struct{}{}
}

// FeltCleared returns if the "felt" field was cleared in this mutation.
func (m *ReportMutation) FeltCleared() bool {
	_, ok := m.clearedFields[report.FieldFelt]
	return ok
}

// ResetFelt resets all changes to the "felt" field.
func (m *ReportMutation) ResetFelt() {
	m.felt = nil
	m.addfelt = nil
	delete(m.clearedFields, report.FieldFelt)
}

// SetCdi sets the "cdi" field.
func (m *ReportMutation) SetCdi(f float64) {
	m.cdi = &f
	m.addcdi = nil
}

// Cdi returns the value of the "cdi" field in the mutation.
func (m *ReportMutation) Cdi() (r float64, exists bool) {
	v := m.cdi
	if v == nil {
		return
	}
	return *v, true
}

// OldCdi returns the old "cdi" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCdi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdi: %w", err)
	}
	return oldValue.Cdi, nil
}

// AddCdi adds f to the "cdi" field.
func (m *ReportMutation) AddCdi(f float64) {
	if m.addcdi != nil {
		*m.addcdi += f
	} else {
		m.addcdi = &f
	}
}

// AddedCdi returns the value that was added to the "cdi" field in this mutation.
func (m *ReportMutation) AddedCdi() (r float64, exists bool) {
	v := m.addcdi
	if v == nil {
		return
	}
	return *v, true
}

// ClearCdi clears the value of the "cdi" field.
func (m *ReportMutation) ClearCdi() {
	m.cdi = nil
	m.addcdi = nil
	m.clearedFields[report.FieldCdi] = struct{}{}
}

// CdiCleared returns if the "cdi" field was cleared in this mutation.
func (m *ReportMutation) CdiCleared() bool {
	_, ok := m.clearedFields[report.FieldCdi]
	return ok
}

// ResetCdi resets all changes to the "cdi" field.
func (m *ReportMutation) ResetCdi() {
	m.cdi = nil
	m.addcdi = nil
	delete(m.clearedFields, report.FieldCdi)
}

// SetMmi sets the "mmi" field.
func (m *ReportMutation) SetMmi(f float64) {
	m.mmi = &f
	m.addmmi = nil
}

// Mmi returns the value of the "mmi" field in the mutation.
func (m *ReportMutation) Mmi() (r float64, exists bool) {
	v := m.mmi
	if v == nil {
		return
	}
	return *v, true
}

// OldMmi returns the old "mmi" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldMmi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMmi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMmi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMmi: %w", err)
	}
	return oldValue.Mmi, nil
}

// AddMmi adds f to the "mmi" field.
func (m *ReportMutation) AddMmi(f float64) {
	if m.addmmi != nil {
		*m.addmmi += f
	} else {
		m.addmmi = &f
	}
}

// AddedMmi returns the value that was added to the "mmi" field in this mutation.
func (m *ReportMutation) AddedMmi() (r float64, exists bool) {
	v := m.addmmi
	if v == nil {
		return
	}
	return *v, true
}

// ClearMmi clears the value of the "mmi" field.
func (m *ReportMutation) ClearMmi() {
	m.mmi = nil
	m.addmmi = nil
	m.clearedFields[report.FieldMmi] = struct{}{}
}

// MmiCleared returns if the "mmi" field was cleared in this mutation.
func (m *ReportMutation) MmiCleared() bool {
	_, ok := m.clearedFields[report.FieldMmi]
	return ok
}

// ResetMmi resets all changes to the "mmi" field.
func (m *ReportMutation) ResetMmi() {
	m.mmi = nil
	m.addmmi = nil
	delete(m.clearedFields, report.FieldMmi)
}

// SetAlert sets the "alert" field.
func (m *ReportMutation) SetAlert(s string) {
	m.alert = &s
}

// Alert returns the value of the "alert" field in the mutation.
func (m *ReportMutation) Alert() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlert returns the old "alert" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldAlert(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlert: %w", err)
	}
	return oldValue.Alert, nil
}

// ClearAlert clears the value of the "alert" field.
func (m *ReportMutation) ClearAlert() {
	m.alert = nil
	m.clearedFields[report.FieldAlert] = struct{}{}
}

// AlertCleared returns if the "alert" field was cleared in this mutation.
func (m *ReportMutation) AlertCleared() bool {
	_, ok := m.clearedFields[report.FieldAlert]
	return ok
}

// ResetAlert resets all changes to the "alert" field.
func (m *ReportMutation) ResetAlert() {
	m.alert = nil
	delete(m.clearedFields, report.FieldAlert)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReportMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReportMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReportMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[report.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReportMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[report.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReportMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, report.FieldDeletedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *ReportMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *ReportMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *ReportMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *ReportMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *ReportMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *ReportMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *ReportMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.felt != nil {
		fields = append(fields, report.FieldFelt)
	}
	if m.cdi != nil {
		fields = append(fields, report.FieldCdi)
	}
	if m.mmi != nil {
		fields = append(fields, report.FieldMmi)
	}
	if m.alert != nil {
		fields = append(fields, report.FieldAlert)
	}
	if m.created_at != nil {
		fields = append(fields, report.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, report.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, report.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldFelt:
		return m.Felt()
	case report.FieldCdi:
		return m.Cdi()
	case report.FieldMmi:
		return m.Mmi()
	case report.FieldAlert:
		return m.Alert()
	case report.FieldCreatedAt:
		return m.CreatedAt()
	case report.FieldUpdatedAt:
		return m.UpdatedAt()
	case report.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldFelt:
		return m.OldFelt(ctx)
	case report.FieldCdi:
		return m.OldCdi(ctx)
	case report.FieldMmi:
		return m.OldMmi(ctx)
	case report.FieldAlert:
		return m.OldAlert(ctx)
	case report.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case report.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case report.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFelt(v)
		return nil
	case report.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdi(v)
		return nil
	case report.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMmi(v)
		return nil
	case report.FieldAlert:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlert(v)
		return nil
	case report.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case report.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case report.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	var fields []string
	if m.addfelt != nil {
		fields = append(fields, report.FieldFelt)
	}
	if m.addcdi != nil {
		fields = append(fields, report.FieldCdi)
	}
	if m.addmmi != nil {
		fields = append(fields, report.FieldMmi)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case report.FieldFelt:
		return m.AddedFelt()
	case report.FieldCdi:
		return m.AddedCdi()
	case report.FieldMmi:
		return m.AddedMmi()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case report.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFelt(v)
		return nil
	case report.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdi(v)
		return nil
	case report.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMmi(v)
		return nil
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldFelt) {
		fields = append(fields, report.FieldFelt)
	}
	if m.FieldCleared(report.FieldCdi) {
		fields = append(fields, report.FieldCdi)
	}
	if m.FieldCleared(report.FieldMmi) {
		fields = append(fields, report.FieldMmi)
	}
	if m.FieldCleared(report.FieldAlert) {
		fields = append(fields, report.FieldAlert)
	}
	if m.FieldCleared(report.FieldDeletedAt) {
		fields = append(fields, report.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldFelt:
		m.ClearFelt()
		return nil
	case report.FieldCdi:
		m.ClearCdi()
		return nil
	case report.FieldMmi:
		m.ClearMmi()
		return nil
	case report.FieldAlert:
		m.ClearAlert()
		return nil
	case report.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldFelt:
		m.ResetFelt()
		return nil
	case report.FieldCdi:
		m.ResetCdi()
		return nil
	case report.FieldMmi:
		m.ResetMmi()
		return nil
	case report.FieldAlert:
		m.ResetAlert()
		return nil
	case report.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case report.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case report.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquakes != nil {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearthquakes != nil {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquakes {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeEarthquakes:
		return m.clearedearthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	login_time    *time.Time
	last_activity *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SessionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SessionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[session.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, session.FieldUserID)
}

// SetLoginTime sets the "login_time" field.
func (m *SessionMutation) SetLoginTime(t time.Time) {
	m.login_time = &t
}

// LoginTime returns the value of the "login_time" field in the mutation.
func (m *SessionMutation) LoginTime() (r time.Time, exists bool) {
	v := m.login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTime returns the old "login_time" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTime: %w", err)
	}
	return oldValue.LoginTime, nil
}

// ResetLoginTime resets all changes to the "login_time" field.
func (m *SessionMutation) ResetLoginTime() {
	m.login_time = nil
}

// SetLastActivity sets the "last_activity" field.
func (m *SessionMutation) SetLastActivity(t time.Time) {
	m.last_activity = &t
}

// LastActivity returns the value of the "last_activity" field in the mutation.
func (m *SessionMutation) LastActivity() (r time.Time, exists bool) {
	v := m.last_activity
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActivity returns the old "last_activity" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldLastActivity(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActivity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActivity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActivity: %w", err)
	}
	return oldValue.LastActivity, nil
}

// ResetLastActivity resets all changes to the "last_activity" field.
func (m *SessionMutation) ResetLastActivity() {
	m.last_activity = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.login_time != nil {
		fields = append(fields, session.FieldLoginTime)
	}
	if m.last_activity != nil {
		fields = append(fields, session.FieldLastActivity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldLoginTime:
		return m.LoginTime()
	case session.FieldLastActivity:
		return m.LastActivity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldLoginTime:
		return m.OldLoginTime(ctx)
	case session.FieldLastActivity:
		return m.OldLastActivity(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTime(v)
		return nil
	case session.FieldLastActivity:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActivity(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldUserID) {
		fields = append(fields, session.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldLoginTime:
		m.ResetLoginTime()
		return nil
	case session.FieldLastActivity:
		m.ResetLastActivity()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	source_earthquakes        map[int]struct{}
	removedsource_earthquakes map[int]struct{}
	clearedsource_earthquakes bool
	done                      bool
	oldValue                  func(context.Context) (*Source, error)
	predicates                []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id int) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Source entities.
func (m *SourceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SourceMutation) ClearName() {
	m.name = nil
	m.clearedFields[source.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SourceMutation) NameCleared() bool {
	_, ok := m.clearedFields[source.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, source.FieldName)
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[source.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[source.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, source.FieldDeletedAt)
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by ids.
func (m *SourceMutation) AddSourceEarthquakeIDs(ids ...int) {
	if m.source_earthquakes == nil {
		m.source_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.source_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearSourceEarthquakes clears the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *SourceMutation) ClearSourceEarthquakes() {
	m.clearedsource_earthquakes = true
}

// SourceEarthquakesCleared reports if the "source_earthquakes" edge to the SourceEarthquake entity was cleared.
func (m *SourceMutation) SourceEarthquakesCleared() bool {
	return m.clearedsource_earthquakes
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (m *SourceMutation) RemoveSourceEarthquakeIDs(ids ...int) {
	if m.removedsource_earthquakes == nil {
		m.removedsource_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.source_earthquakes, ids[i])
		m.removedsource_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedSourceEarthquakes returns the removed IDs of the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *SourceMutation) RemovedSourceEarthquakesIDs() (ids []int) {
	for id := range m.removedsource_earthquakes {
		ids = append(ids, id)
	}
	return
}

// SourceEarthquakesIDs returns the "source_earthquakes" edge IDs in the mutation.
func (m *SourceMutation) SourceEarthquakesIDs() (ids []int) {
	for id := range m.source_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetSourceEarthquakes resets all changes to the "source_earthquakes" edge.
func (m *SourceMutation) ResetSourceEarthquakes() {
	m.source_earthquakes = nil
	m.clearedsource_earthquakes = false
	m.removedsource_earthquakes = nil
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Source, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, source.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, source.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, source.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldName:
		return m.Name()
	case source.FieldCreatedAt:
		return m.CreatedAt()
	case source.FieldUpdatedAt:
		return m.UpdatedAt()
	case source.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case source.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case source.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case source.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case source.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(source.FieldName) {
		fields = append(fields, source.FieldName)
	}
	if m.FieldCleared(source.FieldDeletedAt) {
		fields = append(fields, source.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	switch name {
	case source.FieldName:
		m.ClearName()
		return nil
	case source.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case source.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case source.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source_earthquakes != nil {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.source_earthquakes))
		for id := range m.source_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsource_earthquakes != nil {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedsource_earthquakes))
		for id := range m.removedsource_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource_earthquakes {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeSourceEarthquakes:
		return m.clearedsource_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeSourceEarthquakes:
		m.ResetSourceEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// SourceEarthquakeMutation represents an operation that mutates the SourceEarthquake nodes in the graph.
type SourceEarthquakeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	earthquake        *int
	clearedearthquake bool
	source            *int
	clearedsource     bool
	done              bool
	oldValue          func(context.Context) (*SourceEarthquake, error)
	predicates        []predicate.SourceEarthquake
}

var _ ent.Mutation = (*SourceEarthquakeMutation)(nil)

// sourceearthquakeOption allows management of the mutation configuration using functional options.
type sourceearthquakeOption func(*SourceEarthquakeMutation)

// newSourceEarthquakeMutation creates new mutation for the SourceEarthquake entity.
func newSourceEarthquakeMutation(c config, op Op, opts ...sourceearthquakeOption) *SourceEarthquakeMutation {
	m := &SourceEarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceEarthquakeID sets the ID field of the mutation.
func withSourceEarthquakeID(id int) sourceearthquakeOption {
	return func(m *SourceEarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceEarthquake
		)
		m.oldValue = func(ctx context.Context) (*SourceEarthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceEarthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceEarthquake sets the old SourceEarthquake of the mutation.
func withSourceEarthquake(node *SourceEarthquake) sourceearthquakeOption {
	return func(m *SourceEarthquakeMutation) {
		m.oldValue = func(context.Context) (*SourceEarthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceEarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceEarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceEarthquake entities.
func (m *SourceEarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceEarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceEarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceEarthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSID sets the "s_id" field.
func (m *SourceEarthquakeMutation) SetSID(i int) {
	m.source = &i
}

// SID returns the value of the "s_id" field in the mutation.
func (m *SourceEarthquakeMutation) SID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSID returns the old "s_id" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSID: %w", err)
	}
	return oldValue.SID, nil
}

// ClearSID clears the value of the "s_id" field.
func (m *SourceEarthquakeMutation) ClearSID() {
	m.source = nil
	m.clearedFields[sourceearthquake.FieldSID] = struct{}{}
}

// SIDCleared returns if the "s_id" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) SIDCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldSID]
	return ok
}

// ResetSID resets all changes to the "s_id" field.
func (m *SourceEarthquakeMutation) ResetSID() {
	m.source = nil
	delete(m.clearedFields, sourceearthquake.FieldSID)
}

// SetEqID sets the "eq_id" field.
func (m *SourceEarthquakeMutation) SetEqID(i int) {
	m.earthquake = &i
}

// EqID returns the value of the "eq_id" field in the mutation.
func (m *SourceEarthquakeMutation) EqID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEqID returns the old "eq_id" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldEqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqID: %w", err)
	}
	return oldValue.EqID, nil
}

// ClearEqID clears the value of the "eq_id" field.
func (m *SourceEarthquakeMutation) ClearEqID() {
	m.earthquake = nil
	m.clearedFields[sourceearthquake.FieldEqID] = struct{}{}
}

// EqIDCleared returns if the "eq_id" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) EqIDCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldEqID]
	return ok
}

// ResetEqID resets all changes to the "eq_id" field.
func (m *SourceEarthquakeMutation) ResetEqID() {
	m.earthquake = nil
	delete(m.clearedFields, sourceearthquake.FieldEqID)
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceEarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceEarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceEarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceEarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceEarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceEarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceEarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceEarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceEarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sourceearthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceEarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sourceearthquake.FieldDeletedAt)
}

// SetEarthquakeID sets the "earthquake" edge to the Earthquake entity by id.
func (m *SourceEarthquakeMutation) SetEarthquakeID(id int) {
	m.earthquake = &id
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *SourceEarthquakeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[sourceearthquake.FieldEqID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *SourceEarthquakeMutation) EarthquakeCleared() bool {
	return m.EqIDCleared() || m.clearedearthquake
}

// EarthquakeID returns the "earthquake" edge ID in the mutation.
func (m *SourceEarthquakeMutation) EarthquakeID() (id int, exists bool) {
	if m.earthquake != nil {
		return *m.earthquake, true
	}
	return
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *SourceEarthquakeMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *SourceEarthquakeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// SetSourceID sets the "source" edge to the Source entity by id.
func (m *SourceEarthquakeMutation) SetSourceID(id int) {
	m.source = &id
}

// ClearSource clears the "source" edge to the Source entity.
func (m *SourceEarthquakeMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[sourceearthquake.FieldSID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the Source entity was cleared.
func (m *SourceEarthquakeMutation) SourceCleared() bool {
	return m.SIDCleared() || m.clearedsource
}

// SourceID returns the "source" edge ID in the mutation.
func (m *SourceEarthquakeMutation) SourceID() (id int, exists bool) {
	if m.source != nil {
		return *m.source, true
	}
	return
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *SourceEarthquakeMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *SourceEarthquakeMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the SourceEarthquakeMutation builder.
func (m *SourceEarthquakeMutation) Where(ps ...predicate.SourceEarthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceEarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceEarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceEarthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceEarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceEarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceEarthquake).
func (m *SourceEarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceEarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.source != nil {
		fields = append(fields, sourceearthquake.FieldSID)
	}
	if m.earthquake != nil {
		fields = append(fields, sourceearthquake.FieldEqID)
	}
	if m.created_at != nil {
		fields = append(fields, sourceearthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sourceearthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sourceearthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceEarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourceearthquake.FieldSID:
		return m.SID()
	case sourceearthquake.FieldEqID:
		return m.EqID()
	case sourceearthquake.FieldCreatedAt:
		return m.CreatedAt()
	case sourceearthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case sourceearthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceEarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourceearthquake.FieldSID:
		return m.OldSID(ctx)
	case sourceearthquake.FieldEqID:
		return m.OldEqID(ctx)
	case sourceearthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sourceearthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sourceearthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourceearthquake.FieldSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSID(v)
		return nil
	case sourceearthquake.FieldEqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqID(v)
		return nil
	case sourceearthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sourceearthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sourceearthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceEarthquakeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceEarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceEarthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceEarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourceearthquake.FieldSID) {
		fields = append(fields, sourceearthquake.FieldSID)
	}
	if m.FieldCleared(sourceearthquake.FieldEqID) {
		fields = append(fields, sourceearthquake.FieldEqID)
	}
	if m.FieldCleared(sourceearthquake.FieldDeletedAt) {
		fields = append(fields, sourceearthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceEarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceEarthquakeMutation) ClearField(name string) error {
	switch name {
	case sourceearthquake.FieldSID:
		m.ClearSID()
		return nil
	case sourceearthquake.FieldEqID:
		m.ClearEqID()
		return nil
	case sourceearthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceEarthquakeMutation) ResetField(name string) error {
	switch name {
	case sourceearthquake.FieldSID:
		m.ResetSID()
		return nil
	case sourceearthquake.FieldEqID:
		m.ResetEqID()
		return nil
	case sourceearthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sourceearthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sourceearthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceEarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquake != nil {
		edges = append(edges, sourceearthquake.EdgeEarthquake)
	}
	if m.source != nil {
		edges = append(edges, sourceearthquake.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceEarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	case sourceearthquake.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceEarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceEarthquakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceEarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquake {
		edges = append(edges, sourceearthquake.EdgeEarthquake)
	}
	if m.clearedsource {
		edges = append(edges, sourceearthquake.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceEarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		return m.clearedearthquake
	case sourceearthquake.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceEarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	case sourceearthquake.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceEarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	case sourceearthquake.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op              Op
	typ             string
	id              *int
	token_value     *string
	expiration_time *time.Time
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Token, error)
	predicates      []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TokenMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TokenMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[token.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, token.FieldUserID)
}

// SetTokenValue sets the "token_value" field.
func (m *TokenMutation) SetTokenValue(s string) {
	m.token_value = &s
}

// TokenValue returns the value of the "token_value" field in the mutation.
func (m *TokenMutation) TokenValue() (r string, exists bool) {
	v := m.token_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValue returns the old "token_value" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValue: %w", err)
	}
	return oldValue.TokenValue, nil
}

// ResetTokenValue resets all changes to the "token_value" field.
func (m *TokenMutation) ResetTokenValue() {
	m.token_value = nil
}

// SetExpirationTime sets the "expiration_time" field.
func (m *TokenMutation) SetExpirationTime(t time.Time) {
	m.expiration_time = &t
}

// ExpirationTime returns the value of the "expiration_time" field in the mutation.
func (m *TokenMutation) ExpirationTime() (r time.Time, exists bool) {
	v := m.expiration_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationTime returns the old "expiration_time" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpirationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationTime: %w", err)
	}
	return oldValue.ExpirationTime, nil
}

// ResetExpirationTime resets all changes to the "expiration_time" field.
func (m *TokenMutation) ResetExpirationTime() {
	m.expiration_time = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.token_value != nil {
		fields = append(fields, token.FieldTokenValue)
	}
	if m.expiration_time != nil {
		fields = append(fields, token.FieldExpirationTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldUserID:
		return m.UserID()
	case token.FieldTokenValue:
		return m.TokenValue()
	case token.FieldExpirationTime:
		return m.ExpirationTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldTokenValue:
		return m.OldTokenValue(ctx)
	case token.FieldExpirationTime:
		return m.OldExpirationTime(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldTokenValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValue(v)
		return nil
	case token.FieldExpirationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationTime(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldUserID) {
		fields = append(fields, token.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldTokenValue:
		m.ResetTokenValue()
		return nil
	case token.FieldExpirationTime:
		m.ResetExpirationTime()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	username                      *string
	email                         *string
	password                      *string
	role                          *int
	addrole                       *int
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	clearedFields                 map[string]struct{}
	session                       map[int]struct{}
	removedsession                map[int]struct{}
	clearedsession                bool
	password_reset_request        map[int]struct{}
	removedpassword_reset_request map[int]struct{}
	clearedpassword_reset_request bool
	credentials                   map[int]struct{}
	removedcredentials            map[int]struct{}
	clearedcredentials            bool
	token                         map[int]struct{}
	removedtoken                  map[int]struct{}
	clearedtoken                  bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddSessionIDs adds the "session" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.session == nil {
		m.session = make(map[int]struct{})
	}
	for i := range ids {
		m.session[ids[i]] = struct{}{}
	}
}

// ClearSession clears the "session" edge to the Session entity.
func (m *UserMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *UserMutation) SessionCleared() bool {
	return m.clearedsession
}

// RemoveSessionIDs removes the "session" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsession == nil {
		m.removedsession = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.session, ids[i])
		m.removedsession[ids[i]] = struct{}{}
	}
}

// RemovedSession returns the removed IDs of the "session" edge to the Session entity.
func (m *UserMutation) RemovedSessionIDs() (ids []int) {
	for id := range m.removedsession {
		ids = append(ids, id)
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
func (m *UserMutation) SessionIDs() (ids []int) {
	for id := range m.session {
		ids = append(ids, id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *UserMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
	m.removedsession = nil
}

// AddPasswordResetRequestIDs adds the "password_reset_request" edge to the PasswordResetRequest entity by ids.
func (m *UserMutation) AddPasswordResetRequestIDs(ids ...int) {
	if m.password_reset_request == nil {
		m.password_reset_request = make(map[int]struct{})
	}
	for i := range ids {
		m.password_reset_request[ids[i]] = struct{}{}
	}
}

// ClearPasswordResetRequest clears the "password_reset_request" edge to the PasswordResetRequest entity.
func (m *UserMutation) ClearPasswordResetRequest() {
	m.clearedpassword_reset_request = true
}

// PasswordResetRequestCleared reports if the "password_reset_request" edge to the PasswordResetRequest entity was cleared.
func (m *UserMutation) PasswordResetRequestCleared() bool {
	return m.clearedpassword_reset_request
}

// RemovePasswordResetRequestIDs removes the "password_reset_request" edge to the PasswordResetRequest entity by IDs.
func (m *UserMutation) RemovePasswordResetRequestIDs(ids ...int) {
	if m.removedpassword_reset_request == nil {
		m.removedpassword_reset_request = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.password_reset_request, ids[i])
		m.removedpassword_reset_request[ids[i]] = struct{}{}
	}
}

// RemovedPasswordResetRequest returns the removed IDs of the "password_reset_request" edge to the PasswordResetRequest entity.
func (m *UserMutation) RemovedPasswordResetRequestIDs() (ids []int) {
	for id := range m.removedpassword_reset_request {
		ids = append(ids, id)
	}
	return
}

// PasswordResetRequestIDs returns the "password_reset_request" edge IDs in the mutation.
func (m *UserMutation) PasswordResetRequestIDs() (ids []int) {
	for id := range m.password_reset_request {
		ids = append(ids, id)
	}
	return
}

// ResetPasswordResetRequest resets all changes to the "password_reset_request" edge.
func (m *UserMutation) ResetPasswordResetRequest() {
	m.password_reset_request = nil
	m.clearedpassword_reset_request = false
	m.removedpassword_reset_request = nil
}

// AddCredentialIDs adds the "credentials" edge to the Credentials entity by ids.
func (m *UserMutation) AddCredentialIDs(ids ...int) {
	if m.credentials == nil {
		m.credentials = make(map[int]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credentials entity.
func (m *UserMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credentials entity was cleared.
func (m *UserMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credentials entity by IDs.
func (m *UserMutation) RemoveCredentialIDs(ids ...int) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credentials entity.
func (m *UserMutation) RemovedCredentialsIDs() (ids []int) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *UserMutation) CredentialsIDs() (ids []int) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *UserMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddTokenIDs adds the "token" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int) {
	if m.token == nil {
		m.token = make(map[int]struct{})
	}
	for i := range ids {
		m.token[ids[i]] = struct{}{}
	}
}

// ClearToken clears the "token" edge to the Token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// RemoveTokenIDs removes the "token" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtoken == nil {
		m.removedtoken = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.token, ids[i])
		m.removedtoken[ids[i]] = struct{}{}
	}
}

// RemovedToken returns the removed IDs of the "token" edge to the Token entity.
func (m *UserMutation) RemovedTokenIDs() (ids []int) {
	for id := range m.removedtoken {
		ids = append(ids, id)
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
func (m *UserMutation) TokenIDs() (ids []int) {
	for id := range m.token {
		ids = append(ids, id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
	m.removedtoken = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.session != nil {
		edges = append(edges, user.EdgeSession)
	}
	if m.password_reset_request != nil {
		edges = append(edges, user.EdgePasswordResetRequest)
	}
	if m.credentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSession:
		ids := make([]ent.Value, 0, len(m.session))
		for id := range m.session {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetRequest:
		ids := make([]ent.Value, 0, len(m.password_reset_request))
		for id := range m.password_reset_request {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeToken:
		ids := make([]ent.Value, 0, len(m.token))
		for id := range m.token {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsession != nil {
		edges = append(edges, user.EdgeSession)
	}
	if m.removedpassword_reset_request != nil {
		edges = append(edges, user.EdgePasswordResetRequest)
	}
	if m.removedcredentials != nil {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.removedtoken != nil {
		edges = append(edges, user.EdgeToken)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSession:
		ids := make([]ent.Value, 0, len(m.removedsession))
		for id := range m.removedsession {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswordResetRequest:
		ids := make([]ent.Value, 0, len(m.removedpassword_reset_request))
		for id := range m.removedpassword_reset_request {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeToken:
		ids := make([]ent.Value, 0, len(m.removedtoken))
		for id := range m.removedtoken {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsession {
		edges = append(edges, user.EdgeSession)
	}
	if m.clearedpassword_reset_request {
		edges = append(edges, user.EdgePasswordResetRequest)
	}
	if m.clearedcredentials {
		edges = append(edges, user.EdgeCredentials)
	}
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSession:
		return m.clearedsession
	case user.EdgePasswordResetRequest:
		return m.clearedpassword_reset_request
	case user.EdgeCredentials:
		return m.clearedcredentials
	case user.EdgeToken:
		return m.clearedtoken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSession:
		m.ResetSession()
		return nil
	case user.EdgePasswordResetRequest:
		m.ResetPasswordResetRequest()
		return nil
	case user.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case user.EdgeToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
